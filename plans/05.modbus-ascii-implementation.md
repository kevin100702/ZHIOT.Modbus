# Feature Implementation Plan: modbus-ascii-implementation

## âœ… å¾…åŠæ¸…å•

- [ ] å®šä¹‰ Modbus ASCII æ ¸å¿ƒç±»å‹å’Œå¸¸é‡
- [ ] å®ç° LRC æ ¡éªŒç®—æ³•
- [ ] åˆ›å»º ASCII ç¼–è§£ç å·¥å…·ç±»
- [ ] å®ç° Modbus ASCII ADU æ„å»ºå™¨å’Œè§£æå™¨
- [ ] å®ç° ModbusAsciiClient å®¢æˆ·ç«¯
- [ ] æ‰©å±• ModbusClientFactory æ”¯æŒ ASCII å®¢æˆ·ç«¯åˆ›å»º
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™é›†æˆæµ‹è¯•å’Œç¤ºä¾‹ä»£ç 
- [ ] æ›´æ–°æ–‡æ¡£å’Œç¤ºä¾‹
- [ ] Final Review and Testing

## ğŸ” åˆ†æä¸è°ƒæŸ¥

### ä»£ç åº“ç»“æ„

å½“å‰é¡¹ç›®å·²æˆåŠŸå®ç° Modbus TCP å’Œ RTU ä¸¤ç§åè®®ï¼Œé¡¹ç›®ç»“æ„æ¸…æ™°ï¼š

```
src/ZHIOT.Modbus/
â”œâ”€â”€ Abstractions/
â”‚   â”œâ”€â”€ IModbusClient.cs      # ç»Ÿä¸€çš„å®¢æˆ·ç«¯æ¥å£
â”‚   â””â”€â”€ ITransport.cs         # ä¼ è¾“å±‚æ¥å£
â”œâ”€â”€ Core/
â”‚   â”œâ”€â”€ ModbusPduBuilder.cs     # PDU æ„å»ºå™¨ï¼ˆæ‰€æœ‰åè®®å…±ç”¨ï¼‰
â”‚   â”œâ”€â”€ ModbusPduParser.cs      # PDU è§£æå™¨ï¼ˆæ‰€æœ‰åè®®å…±ç”¨ï¼‰
â”‚   â”œâ”€â”€ ModbusRtuAduBuilder.cs  # RTU ADU æ„å»ºå™¨
â”‚   â”œâ”€â”€ ModbusRtuAduParser.cs   # RTU ADU è§£æå™¨
â”‚   â”œâ”€â”€ ModbusCrc16.cs          # CRC-16 æ ¡éªŒï¼ˆRTU ç‰¹æœ‰ï¼‰
â”‚   â”œâ”€â”€ ByteOrder.cs            # å­—èŠ‚åºå®šä¹‰
â”‚   â”œâ”€â”€ ModbusRtuTypes.cs       # RTU ç±»å‹å®šä¹‰
â”‚   â””â”€â”€ ModbusTypes.cs          # å…±ç”¨ç±»å‹å®šä¹‰
â”œâ”€â”€ Client/
â”‚   â”œâ”€â”€ ModbusTcpClient.cs      # TCP å®¢æˆ·ç«¯
â”‚   â””â”€â”€ ModbusRtuClient.cs      # RTU å®¢æˆ·ç«¯
â”œâ”€â”€ Transport/
â”‚   â”œâ”€â”€ TcpTransport.cs         # TCP ä¼ è¾“å±‚
â”‚   â””â”€â”€ SerialPortTransport.cs  # ä¸²å£ä¼ è¾“å±‚ï¼ˆRTUï¼‰
â”œâ”€â”€ Utils/
â”‚   â””â”€â”€ ModbusDataConverter.cs  # é«˜æ€§èƒ½æ•°æ®è½¬æ¢å™¨
â””â”€â”€ ModbusClientFactory.cs      # å®¢æˆ·ç«¯å·¥å‚
```

### å½“å‰æ¶æ„åˆ†æ

**TCP å’Œ RTU çš„å…±åŒç‚¹ï¼š**
- éƒ½ä½¿ç”¨ç›¸åŒçš„ PDU æ ¼å¼ï¼ˆç”± `ModbusPduBuilder`/`ModbusPduParser` å¤„ç†ï¼‰
- éƒ½å…±äº« `IModbusClient` æ¥å£
- éƒ½æ”¯æŒæ‰©å±•æ•°æ®ç±»å‹ã€å­—èŠ‚åºã€åœ°å€æ¨¡å¼ç­‰åŠŸèƒ½
- éƒ½åŸºäº `System.IO.Pipelines` å®ç°é«˜æ€§èƒ½ I/O

**TCP å’Œ RTU çš„åŒºåˆ«ï¼š**

| ç‰¹æ€§ | TCP | RTU |
|------|-----|-----|
| å¸§å¤´ | MBAP Header (7 bytes) | Slave ID (1 byte) |
| æ ¡éªŒ | TCP å±‚ä¿è¯ | CRC-16 (2 bytes) |
| ç¼–ç  | äºŒè¿›åˆ¶ | äºŒè¿›åˆ¶ |
| å¸§è¾¹ç•Œ | åŸºäºé•¿åº¦å­—æ®µ | åŸºäº 3.5 å­—ç¬¦é™é»˜æœŸ + CRC |

**ASCII åè®®çš„ç‰¹ç‚¹ï¼š**
- å¸§å¤´ï¼š`:` (å†’å·ï¼ŒASCII 0x3A)
- å¸§å°¾ï¼š`\r\n` (å›è½¦æ¢è¡Œ)
- ç¼–ç ï¼šæ‰€æœ‰æ•°æ®ä»¥ ASCII åå…­è¿›åˆ¶ç¼–ç ï¼ˆå¦‚ 0xFF â†’ "FF"ï¼‰
- æ ¡éªŒï¼šLRC-8 (çºµå‘å†—ä½™æ ¡éªŒ)
- å¸§ç»“æ„ï¼š`:` + Slave ID(2) + Function Code(2) + Data(NÃ—2) + LRC(2) + `\r\n`

### ä¾èµ–å…³ç³»ä¸é›†æˆç‚¹

**ä¸ç°æœ‰ä»£ç çš„é›†æˆï¼š**
1. **å…±äº« PDU å±‚** - ä½¿ç”¨ç›¸åŒçš„ `ModbusPduBuilder` å’Œ `ModbusPduParser`
2. **å…±äº«æ¥å£** - å®ç°ç›¸åŒçš„ `IModbusClient` æ¥å£
3. **å…±äº«æ•°æ®è½¬æ¢å™¨** - å¤ç”¨ `ModbusDataConverter` å¤„ç†æ‰©å±•æ•°æ®ç±»å‹
4. **å…±äº«ä¼ è¾“åŸºç¡€** - ä½¿ç”¨ `System.IO.Pipelines` å®ç°é«˜æ€§èƒ½ I/O

**æ–°å¢ä¾èµ–ï¼š**
- æ— æ–°çš„ NuGet åŒ…ä¾èµ–
- æ‰€æœ‰ä¾èµ–å·²åœ¨ TCP/RTU ä¸­æ»¡è¶³

### æŠ€æœ¯è€ƒè™‘ä¸æŒ‘æˆ˜

#### æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜

1. **ASCII ç¼–ç çš„é¢å¤–å¤„ç†**
   - RTU æ•°æ®ä¸ºäºŒè¿›åˆ¶ï¼Œç›´æ¥ä¼ è¾“
   - ASCII æ•°æ®éœ€è¦è½¬æ¢ï¼šæ¯ä¸ªå­—èŠ‚è½¬ä¸º 2 ä¸ª ASCII åå…­è¿›åˆ¶å­—ç¬¦
   - å¢åŠ äº† 50% çš„æ•°æ®é‡ä½†é™ä½äº†å¹²æ‰°æ•æ„Ÿæ€§
   - éœ€è¦é«˜æ•ˆçš„ç¼–ç /è§£ç å®ç°

2. **LRC-8 æ ¡éªŒç®—æ³•**
   - RTU ä½¿ç”¨ CRC-16ï¼ˆ2 å­—èŠ‚ï¼‰ï¼ŒASCII ä½¿ç”¨ LRC-8ï¼ˆ1 å­—èŠ‚ï¼‰
   - LRC æ˜¯ç®€å•çš„çºµå‘å†—ä½™æ ¡éªŒï¼šå¯¹æ‰€æœ‰å­—èŠ‚æ±‚å’Œï¼Œå–åï¼Œå–ä½ 8 ä½
   - ç›¸æ¯” CRC-16 è®¡ç®—é‡å°ï¼Œä½†é”™è¯¯æ£€æµ‹èƒ½åŠ›ç•¥å¼±

3. **å¸§è¾¹ç•Œæ£€æµ‹**
   - RTUï¼šåŸºäºé¢„æœŸé•¿åº¦å’Œ CRC æ ¡éªŒ
   - ASCIIï¼šåŸºäºå¸§å¤´ `:` å’Œå¸§å°¾ `\r\n`
   - ASCII å¸§è¾¹ç•Œæ£€æµ‹æ›´ç®€å•ï¼ˆåŸºäºç‰¹æ®Šå­—ç¬¦ï¼‰

4. **å…¼å®¹æ€§è€ƒè™‘**
   - ASCII é€šå¸¸ç”¨äºé•¿è·ç¦»ã€å¹²æ‰°ç¯å¢ƒçš„é€šä¿¡
   - ä¸ RTU ä¸å…¼å®¹ï¼Œéœ€è¦å•ç‹¬çš„å®ç°
   - ä½† PDU æ ¼å¼å®Œå…¨ç›¸åŒï¼Œå¯ä»¥å¤ç”¨

#### è®¾è®¡ç­–ç•¥

1. **éµå¾ªç°æœ‰æ¶æ„**
   - åˆ›å»º `ModbusAsciiClient` ç»§æ‰¿/å®ç° `IModbusClient`
   - åˆ›å»º `ModbusAsciiAduBuilder` å’Œ `ModbusAsciiAduParser` å¤„ç† ASCII ç‰¹å®šçš„å¸§æ ¼å¼
   - åˆ›å»º `ModbusLrc` ç±»ä¼¼ `ModbusCrc16` å¤„ç† LRC æ ¡éªŒ
   - ä½¿ç”¨ `SerialPortTransport`ï¼ˆä¸²å£é€šä¿¡ï¼‰æˆ–æ–°å»º TCP/å…¶ä»–ä¼ è¾“å±‚

2. **æ€§èƒ½ä¼˜åŒ–**
   - ASCII ç¼–ç /è§£ç ä½¿ç”¨ `Span<T>` å®ç°é›¶åˆ†é…
   - åˆ©ç”¨æ•°ç»„è€Œéå­—ç¬¦ä¸²å¤„ç†åå…­è¿›åˆ¶è½¬æ¢
   - ä½¿ç”¨å­—èŠ‚çº§æ“ä½œè€Œéå­—ç¬¦ä¸²æ“ä½œ

3. **API ä¸€è‡´æ€§**
   - `ModbusAsciiClient` çš„å…¬å…±æ¥å£ä¸ `ModbusTcpClient`/`ModbusRtuClient` å®Œå…¨ç›¸åŒ
   - æ”¯æŒç›¸åŒçš„æ‰©å±•æ•°æ®ç±»å‹ã€å­—èŠ‚åºã€åœ°å€æ¨¡å¼
   - å·¥å‚æ–¹æ³• `ModbusClientFactory.CreateAsciiClient(...)` éµå¾ªç°æœ‰æ¨¡å¼

## ğŸ“‹ å®ç°è®¡åˆ’

### å‰ç½®æ¡ä»¶

- ç†è§£ Modbus ASCII åè®®è§„èŒƒ
- äº†è§£ LRC-8 æ ¡éªŒç®—æ³•
- ç†è§£ç°æœ‰ RTU å®ç°çš„æ¶æ„
- æ‰€æœ‰ç°æœ‰å•å…ƒæµ‹è¯•åº”é€šè¿‡

### åˆ†æ­¥å®ç°

#### **æ­¥éª¤ 1: å®šä¹‰ ASCII æ ¸å¿ƒç±»å‹**

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusAsciiTypes.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
namespace ZHIOT.Modbus.Core;

/// <summary>
/// Modbus ASCII ADU ç»“æ„å®šä¹‰
/// æ ¼å¼: ':' + SlaveId(2) + FunctionCode(2) + Data(NÃ—2) + LRC(2) + '\r\n'
/// å…¶ä¸­ SlaveId, FunctionCode, Data, LRC éƒ½æ˜¯ ASCII åå…­è¿›åˆ¶è¡¨ç¤º
/// </summary>
public readonly struct AsciiAdu
{
    /// <summary>
    /// ä»ç«™ ID
    /// </summary>
    public byte SlaveId { get; init; }

    /// <summary>
    /// PDU æ•°æ®
    /// </summary>
    public ReadOnlyMemory<byte> Pdu { get; init; }

    /// <summary>
    /// LRC æ ¡éªŒç 
    /// </summary>
    public byte Lrc { get; init; }

    /// <summary>
    /// ASCII ADU æœ€å°é•¿åº¦: ':' + SlaveId(2) + FunctionCode(2) + LRC(2) + '\r\n'
    /// = 1 + 2 + 2 + 2 + 2 = 9 å­—ç¬¦
    /// </summary>
    public const int MinSize = 9;
}

/// <summary>
/// Modbus ASCII çº¿è·¯è®¾ç½®
/// ASCII é€šå¸¸é€šè¿‡ä¸²å£æˆ–ç½‘ç»œè¿æ¥ä½¿ç”¨ï¼Œä½¿ç”¨æ–‡æœ¬è¡Œåè®®
/// </summary>
public class AsciiLineSettings
{
    /// <summary>
    /// ç«¯å£åç§°ï¼ˆä¸²å£å¦‚ "COM1"ï¼Œæˆ–ç½‘ç»œåœ°å€ï¼‰
    /// </summary>
    public string PortName { get; set; } = "COM1";

    /// <summary>
    /// æ³¢ç‰¹ç‡ï¼ˆä»…å½“ä½¿ç”¨ä¸²å£æ—¶æœ‰æ•ˆï¼‰
    /// </summary>
    public int BaudRate { get; set; } = 9600;

    /// <summary>
    /// å¥‡å¶æ ¡éªŒï¼ˆä»…å½“ä½¿ç”¨ä¸²å£æ—¶æœ‰æ•ˆï¼‰
    /// </summary>
    public Parity Parity { get; set; } = Parity.None;

    /// <summary>
    /// æ•°æ®ä½ï¼ˆä»…å½“ä½¿ç”¨ä¸²å£æ—¶æœ‰æ•ˆï¼‰
    /// </summary>
    public int DataBits { get; set; } = 8;

    /// <summary>
    /// åœæ­¢ä½ï¼ˆä»…å½“ä½¿ç”¨ä¸²å£æ—¶æœ‰æ•ˆï¼‰
    /// </summary>
    public StopBits StopBits { get; set; } = StopBits.One;

    /// <summary>
    /// è¯»å–è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    /// </summary>
    public int ReadTimeout { get; set; } = 1000;

    /// <summary>
    /// å†™å…¥è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
    /// </summary>
    public int WriteTimeout { get; set; } = 1000;
}
```

#### **æ­¥éª¤ 2: å®ç° LRC-8 æ ¡éªŒç®—æ³•**

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusLrc.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
namespace ZHIOT.Modbus.Core;

/// <summary>
/// Modbus ASCII LRC-8 æ ¡éªŒç®—æ³•å®ç°
/// LRC (Longitudinal Redundancy Check) - çºµå‘å†—ä½™æ ¡éªŒ
/// ç®—æ³•: LRC = (sum of bytes) XOR 0xFF + 1 = -sum mod 256
/// </summary>
public static class ModbusLrc
{
    /// <summary>
    /// è®¡ç®—æ•°æ®çš„ LRC-8 æ ¡éªŒç 
    /// </summary>
    /// <param name="data">è¦è®¡ç®— LRC çš„æ•°æ®</param>
    /// <returns>LRC-8 æ ¡éªŒç </returns>
    public static byte Calculate(ReadOnlySpan<byte> data)
    {
        // æ±‚å’Œæ‰€æœ‰å­—èŠ‚
        int sum = 0;
        foreach (byte b in data)
        {
            sum += b;
        }

        // LRC = (-sum) mod 256 = (~sum + 1) mod 256
        return (byte)((-sum) & 0xFF);
    }

    /// <summary>
    /// éªŒè¯åŒ…å« LRC çš„å®Œæ•´å¸§ï¼ˆæœ€åä¸€å­—èŠ‚ä¸º LRCï¼‰
    /// </summary>
    /// <param name="frame">åŒ…å« LRC çš„å®Œæ•´å¸§</param>
    /// <returns>å¦‚æœ LRC æ ¡éªŒé€šè¿‡è¿”å› true</returns>
    public static bool Verify(ReadOnlySpan<byte> frame)
    {
        if (frame.Length < 2)
            return false;

        // æå–æ•°æ®éƒ¨åˆ†ï¼ˆä¸åŒ…å«æœ€åä¸€å­—èŠ‚çš„ LRCï¼‰
        var data = frame.Slice(0, frame.Length - 1);

        // æå–å¸§ä¸­çš„ LRC
        byte frameLrc = frame[frame.Length - 1];

        // è®¡ç®—æ•°æ®çš„ LRC
        byte calculatedLrc = Calculate(data);

        return frameLrc == calculatedLrc;
    }
}
```

#### **æ­¥éª¤ 3: åˆ›å»º ASCII ç¼–è§£ç å·¥å…·ç±»**

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusAsciiCodec.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
namespace ZHIOT.Modbus.Core;

/// <summary>
/// Modbus ASCII ç¼–è§£ç å·¥å…·
/// è´Ÿè´£äºŒè¿›åˆ¶æ•°æ®ä¸ ASCII åå…­è¿›åˆ¶çš„ç›¸äº’è½¬æ¢
/// 
/// äºŒè¿›åˆ¶æ ¼å¼: 0xAB -> å­—èŠ‚ 171
/// ASCII æ ¼å¼:  "AB" -> å­—ç¬¦ 'A'(65) å’Œ 'B'(66)
/// </summary>
public static class ModbusAsciiCodec
{
    /// <summary>
    /// åå…­è¿›åˆ¶å­—ç¬¦é›†
    /// </summary>
    private static readonly string HexChars = "0123456789ABCDEF";

    /// <summary>
    /// å°†äºŒè¿›åˆ¶æ•°æ®ç¼–ç ä¸º ASCII åå…­è¿›åˆ¶å­—ç¬¦
    /// ä¾‹å¦‚: 0xAB -> "AB"
    /// </summary>
    /// <param name="data">äºŒè¿›åˆ¶æ•°æ®</param>
    /// <param name="ascii">è¾“å‡º ASCII åå…­è¿›åˆ¶å­—ç¬¦ç¼“å†²åŒºï¼ˆé•¿åº¦åº”ä¸º data.Length * 2ï¼‰</param>
    /// <returns>å†™å…¥çš„å­—ç¬¦æ•°</returns>
    public static int Encode(ReadOnlySpan<byte> data, Span<byte> ascii)
    {
        if (ascii.Length < data.Length * 2)
            throw new ArgumentException("ASCII buffer is too small", nameof(ascii));

        int asciiIndex = 0;
        foreach (byte b in data)
        {
            // é«˜ 4 ä½
            ascii[asciiIndex++] = (byte)HexChars[b >> 4];
            // ä½ 4 ä½
            ascii[asciiIndex++] = (byte)HexChars[b & 0x0F];
        }

        return data.Length * 2;
    }

    /// <summary>
    /// å°† ASCII åå…­è¿›åˆ¶å­—ç¬¦è§£ç ä¸ºäºŒè¿›åˆ¶æ•°æ®
    /// ä¾‹å¦‚: "AB" -> 0xAB
    /// </summary>
    /// <param name="ascii">ASCII åå…­è¿›åˆ¶å­—ç¬¦</param>
    /// <param name="data">è¾“å‡ºäºŒè¿›åˆ¶æ•°æ®ç¼“å†²åŒºï¼ˆé•¿åº¦åº”ä¸º ascii.Length / 2ï¼‰</param>
    /// <returns>å†™å…¥çš„å­—èŠ‚æ•°</returns>
    public static int Decode(ReadOnlySpan<byte> ascii, Span<byte> data)
    {
        if (ascii.Length % 2 != 0)
            throw new ArgumentException("ASCII data length must be even", nameof(ascii));

        if (data.Length < ascii.Length / 2)
            throw new ArgumentException("Data buffer is too small", nameof(data));

        int dataIndex = 0;
        for (int i = 0; i < ascii.Length; i += 2)
        {
            byte high = HexCharToNibble(ascii[i]);
            byte low = HexCharToNibble(ascii[i + 1]);

            if (high == 0xFF || low == 0xFF)
                throw new FormatException($"Invalid hex character at position {i}");

            data[dataIndex++] = (byte)((high << 4) | low);
        }

        return ascii.Length / 2;
    }

    /// <summary>
    /// å°†å•ä¸ªåå…­è¿›åˆ¶å­—ç¬¦è½¬æ¢ä¸º 4 ä½å€¼
    /// è¿”å› 0xFF è¡¨ç¤ºæ— æ•ˆå­—ç¬¦
    /// </summary>
    private static byte HexCharToNibble(byte ascii)
    {
        if (ascii >= (byte)'0' && ascii <= (byte)'9')
            return (byte)(ascii - (byte)'0');
        if (ascii >= (byte)'A' && ascii <= (byte)'F')
            return (byte)(ascii - (byte)'A' + 10);
        if (ascii >= (byte)'a' && ascii <= (byte)'f')
            return (byte)(ascii - (byte)'a' + 10);

        return 0xFF; // æ— æ•ˆå­—ç¬¦
    }

    /// <summary>
    /// å°†äºŒè¿›åˆ¶æ•°æ®ç¼–ç ä¸º ASCII åå…­è¿›åˆ¶å­—ç¬¦ä¸²
    /// </summary>
    public static string EncodeToString(ReadOnlySpan<byte> data)
    {
        Span<byte> ascii = stackalloc byte[data.Length * 2];
        Encode(data, ascii);
        return System.Text.Encoding.ASCII.GetString(ascii);
    }

    /// <summary>
    /// å°† ASCII åå…­è¿›åˆ¶å­—ç¬¦ä¸²è§£ç ä¸ºäºŒè¿›åˆ¶æ•°æ®
    /// </summary>
    public static byte[] DecodeFromString(string ascii)
    {
        var asciiBytes = System.Text.Encoding.ASCII.GetBytes(ascii);
        var data = new byte[asciiBytes.Length / 2];
        Decode(asciiBytes, data);
        return data;
    }
}
```

#### **æ­¥éª¤ 4: å®ç° ASCII ADU æ„å»ºå™¨å’Œè§£æå™¨**

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusAsciiAduBuilder.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
namespace ZHIOT.Modbus.Core;

/// <summary>
/// Modbus ASCII ADU æ„å»ºå™¨
/// è´Ÿè´£å°† SlaveId + PDU å°è£…ä¸ºå®Œæ•´çš„ ASCII ADU
/// æ ¼å¼: ':' + SlaveId(2) + FunctionCode(2) + Data(NÃ—2) + LRC(2) + '\r\n'
/// å…¶ä¸­æ‰€æœ‰åå…­è¿›åˆ¶å­—æ®µéƒ½æ˜¯ ASCII ç¼–ç 
/// </summary>
public static class ModbusAsciiAduBuilder
{
    /// <summary>
    /// æ„å»ºå®Œæ•´çš„ ASCII ADU
    /// </summary>
    /// <param name="buffer">ç›®æ ‡ç¼“å†²åŒºï¼ˆåº”è¶³å¤Ÿå¤§ä»¥å®¹çº³å®Œæ•´ ADUï¼‰</param>
    /// <param name="slaveId">ä»ç«™ ID</param>
    /// <param name="pdu">åè®®æ•°æ®å•å…ƒ</param>
    /// <returns>å†™å…¥çš„æ€»å­—èŠ‚æ•°</returns>
    public static int BuildAdu(Span<byte> buffer, byte slaveId, ReadOnlySpan<byte> pdu)
    {
        // è®¡ç®—æ‰€éœ€çš„ç¼“å†²åŒºå¤§å°:
        // ':' (1) + SlaveId(2) + PDU(NÃ—2) + LRC(2) + '\r\n' (2)
        int requiredSize = 1 + 2 + pdu.Length * 2 + 2 + 2;
        if (buffer.Length < requiredSize)
            throw new ArgumentException("Buffer is too small", nameof(buffer));

        int offset = 0;

        // 1. å†™å…¥å¸§å¤´ ':'
        buffer[offset++] = (byte)':';

        // 2. ç¼–ç  SlaveId
        Span<byte> slaveIdHex = stackalloc byte[2];
        ModbusAsciiCodec.Encode(new[] { slaveId }, slaveIdHex);
        slaveIdHex.CopyTo(buffer.Slice(offset));
        offset += 2;

        // 3. ç¼–ç  PDU (SlaveId + FunctionCode + Data)
        Span<byte> pduHex = stackalloc byte[pdu.Length * 2];
        ModbusAsciiCodec.Encode(pdu, pduHex);
        pduHex.CopyTo(buffer.Slice(offset));
        offset += pdu.Length * 2;

        // 4. è®¡ç®— LRC (åŒ…æ‹¬ SlaveId å’Œ PDU)
        Span<byte> lrcData = stackalloc byte[1 + pdu.Length];
        lrcData[0] = slaveId;
        pdu.CopyTo(lrcData.Slice(1));
        byte lrc = ModbusLrc.Calculate(lrcData);

        // 5. ç¼–ç  LRC
        Span<byte> lrcHex = stackalloc byte[2];
        ModbusAsciiCodec.Encode(new[] { lrc }, lrcHex);
        lrcHex.CopyTo(buffer.Slice(offset));
        offset += 2;

        // 6. å†™å…¥å¸§å°¾ '\r\n'
        buffer[offset++] = (byte)'\r';
        buffer[offset++] = (byte)'\n';

        return offset;
    }
}
```

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusAsciiAduParser.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
namespace ZHIOT.Modbus.Core;

/// <summary>
/// Modbus ASCII ADU è§£æå™¨
/// è´Ÿè´£ä»å®Œæ•´çš„ ASCII ADU ä¸­æå–å’ŒéªŒè¯æ•°æ®
/// æ ¼å¼: ':' + SlaveId(2) + FunctionCode(2) + Data(NÃ—2) + LRC(2) + '\r\n'
/// </summary>
public static class ModbusAsciiAduParser
{
    /// <summary>
    /// ä»å®Œæ•´çš„ ASCII ADU ä¸­æå– PDU
    /// </summary>
    /// <param name="adu">å®Œæ•´çš„ ASCII ADU</param>
    /// <returns>PDU éƒ¨åˆ†çš„æ•°æ®</returns>
    /// <exception cref="InvalidOperationException">å½“ ADU æ ¼å¼é”™è¯¯æˆ– LRC æ ¡éªŒå¤±è´¥æ—¶æŠ›å‡º</exception>
    public static ReadOnlySpan<byte> ExtractPdu(ReadOnlySpan<byte> adu)
    {
        // éªŒè¯å¸§å¤´å’Œå¸§å°¾
        if (adu.Length < AsciiAdu.MinSize)
            throw new InvalidOperationException($"ADU too short: {adu.Length} bytes (minimum {AsciiAdu.MinSize})");

        if (adu[0] != (byte)':')
            throw new InvalidOperationException("Invalid frame header: expected ':'");

        if (adu[adu.Length - 2] != (byte)'\r' || adu[adu.Length - 1] != (byte)'\n')
            throw new InvalidOperationException("Invalid frame trailer: expected '\\r\\n'");

        // ç§»é™¤å¸§å¤´å¸§å°¾ï¼Œä¿ç•™ ASCII æ•°æ®: SlaveId(2) + PDU(NÃ—2) + LRC(2)
        var asciiData = adu.Slice(1, adu.Length - 3);

        // éœ€è¦è‡³å°‘ 2(SlaveId) + 2(FunctionCode) + 2(LRC) = 6 å­—ç¬¦
        if (asciiData.Length < 6 || asciiData.Length % 2 != 0)
            throw new InvalidOperationException("Invalid ASCII data length");

        // è§£ç  ASCII æ•°æ®
        Span<byte> binaryData = stackalloc byte[asciiData.Length / 2];
        ModbusAsciiCodec.Decode(asciiData, binaryData);

        // éªŒè¯ LRC
        // æ ¼å¼: SlaveId(1) + PDU(N) + LRC(1)
        if (!ModbusLrc.Verify(binaryData))
            throw new InvalidOperationException("LRC verification failed");

        // è¿”å› PDU éƒ¨åˆ†ï¼ˆä»ç¬¬ 1 å­—èŠ‚å¼€å§‹ï¼Œåˆ°å€’æ•°ç¬¬ 2 å­—èŠ‚ç»“æŸï¼Œè·³è¿‡æœ€åçš„ LRCï¼‰
        return binaryData.Slice(1, binaryData.Length - 2);
    }

    /// <summary>
    /// ä»å®Œæ•´çš„ ASCII ADU ä¸­æå– SlaveId
    /// </summary>
    /// <param name="adu">å®Œæ•´çš„ ASCII ADU</param>
    /// <returns>ä»ç«™ ID</returns>
    public static byte ExtractSlaveId(ReadOnlySpan<byte> adu)
    {
        if (adu.Length < 3)
            throw new InvalidOperationException("ADU is too short");

        if (adu[0] != (byte)':')
            throw new InvalidOperationException("Invalid frame header");

        // è§£ç  SlaveId (ç¬¬ 1-2 ä¸ªå­—ç¬¦)
        Span<byte> slaveIdBinary = stackalloc byte[1];
        ModbusAsciiCodec.Decode(adu.Slice(1, 2), slaveIdBinary);

        return slaveIdBinary[0];
    }

    /// <summary>
    /// éªŒè¯ ADU çš„ LRC
    /// </summary>
    /// <param name="adu">å®Œæ•´çš„ ASCII ADU</param>
    /// <returns>å¦‚æœ LRC æ ¡éªŒé€šè¿‡è¿”å› true</returns>
    public static bool VerifyLrc(ReadOnlySpan<byte> adu)
    {
        try
        {
            // éªŒè¯å¸§å¤´å¸§å°¾
            if (adu.Length < AsciiAdu.MinSize)
                return false;

            if (adu[0] != (byte)':')
                return false;

            if (adu[adu.Length - 2] != (byte)'\r' || adu[adu.Length - 1] != (byte)'\n')
                return false;

            // ç§»é™¤å¸§å¤´å¸§å°¾
            var asciiData = adu.Slice(1, adu.Length - 3);

            if (asciiData.Length < 6 || asciiData.Length % 2 != 0)
                return false;

            // è§£ç å¹¶éªŒè¯
            Span<byte> binaryData = stackalloc byte[asciiData.Length / 2];
            ModbusAsciiCodec.Decode(asciiData, binaryData);

            return ModbusLrc.Verify(binaryData);
        }
        catch
        {
            return false;
        }
    }
}
```

#### **æ­¥éª¤ 5: å®ç° ModbusAsciiClient å®¢æˆ·ç«¯**

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Client/ModbusAsciiClient.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
using System.Buffers;
using System.IO.Pipelines;
using ZHIOT.Modbus.Abstractions;
using ZHIOT.Modbus.Core;
using ZHIOT.Modbus.Utils;

namespace ZHIOT.Modbus.Client;

/// <summary>
/// Modbus ASCII å®¢æˆ·ç«¯å®ç°
/// </summary>
public class ModbusAsciiClient : IModbusClient
{
    private readonly ITransport _transport;
    private readonly SemaphoreSlim _sendLock = new(1, 1);
    private bool _disposed;

    /// <inheritdoc/>
    public bool IsOneBasedAddressing { get; set; }

    /// <inheritdoc/>
    public ByteOrder ByteOrder { get; set; } = ByteOrder.BigEndian;

    /// <summary>
    /// åˆ›å»º Modbus ASCII å®¢æˆ·ç«¯
    /// </summary>
    /// <param name="transport">ä¼ è¾“å±‚å®ç°</param>
    public ModbusAsciiClient(ITransport transport)
    {
        _transport = transport ?? throw new ArgumentNullException(nameof(transport));
    }

    /// <inheritdoc/>
    public Task ConnectAsync(CancellationToken cancellationToken = default)
    {
        return _transport.ConnectAsync(cancellationToken);
    }

    /// <inheritdoc/>
    public Task DisconnectAsync(CancellationToken cancellationToken = default)
    {
        return _transport.CloseAsync(cancellationToken);
    }

    // å¤ç”¨ RTU å®¢æˆ·ç«¯çš„æ‰€æœ‰ä¸šåŠ¡æ–¹æ³•å®ç°
    // (ReadCoilsAsync, ReadHoldingRegistersAsync, ç­‰)
    // å”¯ä¸€çš„åŒºåˆ«åœ¨äº SendRequestAsync ä½¿ç”¨ ASCII ADU æ ¼å¼

    // ... [ç±»ä¼¼ ModbusRtuClient çš„å®Œæ•´æ–¹æ³•å®ç°] ...

    /// <summary>
    /// å‘é€ Modbus ASCII è¯·æ±‚å¹¶æ¥æ”¶å“åº”
    /// </summary>
    private async Task<byte[]> SendRequestAsync(byte slaveId, byte[] pdu, CancellationToken cancellationToken)
    {
        if (!_transport.IsConnected)
            throw new InvalidOperationException("Not connected");

        await _sendLock.WaitAsync(cancellationToken);
        try
        {
            // æ„å»ºå®Œæ•´çš„ ASCII ADU
            Span<byte> adu = stackalloc byte[256];
            int aduLength = ModbusAsciiAduBuilder.BuildAdu(adu, slaveId, pdu);

            // å‘é€è¯·æ±‚
            var output = _transport.Pipe.Output;
            var memory = output.GetMemory(aduLength);
            adu.Slice(0, aduLength).CopyTo(memory.Span);
            output.Advance(aduLength);
            await output.FlushAsync(cancellationToken);

            // æ¥æ”¶å“åº”
            var input = _transport.Pipe.Input;
            var timeout = TimeSpan.FromMilliseconds(1000);
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            cts.CancelAfter(timeout);

            while (true)
            {
                var result = await input.ReadAsync(cts.Token);
                var buffer = result.Buffer;

                if (TryParseResponse(ref buffer, slaveId, out var responsePdu))
                {
                    input.AdvanceTo(buffer.Start);
                    return responsePdu;
                }

                input.AdvanceTo(buffer.Start, buffer.End);

                if (result.IsCompleted)
                    throw new IOException("Connection closed while waiting for response");
            }
        }
        catch (OperationCanceledException) when (!cancellationToken.IsCancellationRequested)
        {
            throw new TimeoutException("Timeout waiting for Modbus ASCII response");
        }
        finally
        {
            _sendLock.Release();
        }
    }

    /// <summary>
    /// å°è¯•ä»ç¼“å†²åŒºè§£æ ASCII å“åº”
    /// </summary>
    private bool TryParseResponse(ref ReadOnlySequence<byte> buffer, byte expectedSlaveId, out byte[] pdu)
    {
        pdu = Array.Empty<byte>();

        // ASCII å¸§çš„æœ€å°é•¿åº¦: ':' + SlaveId(2) + FunctionCode(2) + LRC(2) + '\r\n' = 9
        if (buffer.Length < AsciiAdu.MinSize)
            return false;

        // æŸ¥æ‰¾å¸§å¤´ ':'
        var indexOfStart = buffer.PositionOf((byte)':');
        if (indexOfStart == null)
            return false; // æ²¡æœ‰æ‰¾åˆ°å¸§å¤´

        // è·³è¿‡å¸§å¤´å‰çš„ä»»ä½•æ•°æ®
        buffer = buffer.Slice(indexOfStart.Value);

        // æŸ¥æ‰¾å¸§å°¾ '\r\n'
        var indexOfCr = buffer.PositionOf((byte)'\r');
        if (indexOfCr == null)
            return false; // å¸§æœªå®Œæˆ

        // æ£€æŸ¥æ˜¯å¦æœ‰ '\n'
        var afterCr = buffer.GetPosition(1, indexOfCr.Value);
        if (afterCr == null || buffer.Length <= buffer.GetOffset(afterCr.Value))
            return false;

        var nextByte = buffer.Slice(afterCr.Value);
        if (nextByte.Length == 0 || nextByte.First.Span[0] != (byte)'\n')
            return false;

        // æå–å®Œæ•´çš„å¸§
        var frameEndPosition = buffer.GetPosition(1, afterCr.Value);
        int frameLength = (int)buffer.Slice(0, frameEndPosition.Value).Length + 1;

        Span<byte> frame = stackalloc byte[frameLength];
        buffer.Slice(0, frameLength).CopyTo(frame);

        // éªŒè¯ LRC
        if (!ModbusAsciiAduParser.VerifyLrc(frame))
        {
            // LRC é”™è¯¯ï¼Œè·³è¿‡è¿™ä¸€è¡Œ
            buffer = buffer.Slice(frameLength);
            return false;
        }

        // æå– SlaveId
        byte slaveId = ModbusAsciiAduParser.ExtractSlaveId(frame);
        if (slaveId != expectedSlaveId)
        {
            // ä¸æ˜¯æœŸæœ›çš„ä»ç«™ï¼Œè·³è¿‡
            buffer = buffer.Slice(frameLength);
            return false;
        }

        try
        {
            // æå– PDU
            var pduSpan = ModbusAsciiAduParser.ExtractPdu(frame);
            pdu = pduSpan.ToArray();
            
            // ç§»åŠ¨ç¼“å†²åŒºä½ç½®
            buffer = buffer.Slice(frameLength);
            
            return true;
        }
        catch
        {
            // è§£æå¤±è´¥ï¼Œè·³è¿‡è¿™ä¸€è¡Œ
            buffer = buffer.Slice(frameLength);
            return false;
        }
    }

    /// <inheritdoc/>
    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;
        await _transport.DisposeAsync();
        _sendLock.Dispose();
    }

    // ... [å…¶ä»–å®ç°æ–¹æ³•åŒ ModbusRtuClientï¼Œå®Œæ•´å¤åˆ¶æ‰€æœ‰ä¸šåŠ¡æ–¹æ³•] ...
}
```

#### **æ­¥éª¤ 6: æ‰©å±• ModbusClientFactory**

- **æ–‡ä»¶ä¿®æ”¹**: `src/ZHIOT.Modbus/ModbusClientFactory.cs`
- **éœ€è¦çš„å˜æ›´**:

```csharp
/// æ–°å¢æ–¹æ³•
public static IModbusClient CreateAsciiClient(AsciiLineSettings settings)
{
    var transport = new SerialPortTransport(
        new SerialPortSettings
        {
            PortName = settings.PortName,
            BaudRate = settings.BaudRate,
            Parity = settings.Parity,
            DataBits = settings.DataBits,
            StopBits = settings.StopBits,
            ReadTimeout = settings.ReadTimeout,
            WriteTimeout = settings.WriteTimeout
        }
    );
    return new ModbusAsciiClient(transport);
}

/// ä¾¿æ·é‡è½½
public static IModbusClient CreateAsciiClient(
    string portName,
    int baudRate = 9600,
    Parity parity = Parity.None,
    int dataBits = 8,
    StopBits stopBits = StopBits.One)
{
    var settings = new AsciiLineSettings
    {
        PortName = portName,
        BaudRate = baudRate,
        Parity = parity,
        DataBits = dataBits,
        StopBits = stopBits
    };
    return CreateAsciiClient(settings);
}
```

#### **æ­¥éª¤ 7: ç¼–å†™å•å…ƒæµ‹è¯•**

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusLrcTests.cs`
- **æµ‹è¯•å†…å®¹**:
  - æµ‹è¯• LRC è®¡ç®—çš„æ­£ç¡®æ€§ï¼ˆä½¿ç”¨å·²çŸ¥çš„æµ‹è¯•å‘é‡ï¼‰
  - æµ‹è¯• LRC éªŒè¯çš„æ­£ç¡®æ€§
  - æµ‹è¯•è¾¹ç•Œæ¡ä»¶

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusAsciiCodecTests.cs`
- **æµ‹è¯•å†…å®¹**:
  - æµ‹è¯•äºŒè¿›åˆ¶åˆ° ASCII çš„ç¼–ç 
  - æµ‹è¯• ASCII åˆ°äºŒè¿›åˆ¶çš„è§£ç 
  - æµ‹è¯•å¾€è¿”è½¬æ¢
  - æµ‹è¯•æ— æ•ˆè¾“å…¥çš„é”™è¯¯å¤„ç†

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusAsciiAduBuilderTests.cs`
- **æµ‹è¯•å†…å®¹**:
  - æµ‹è¯• ASCII ADU çš„æ„å»º
  - éªŒè¯å¸§å¤´å¸§å°¾çš„æ­£ç¡®æ€§
  - éªŒè¯ LRC çš„è®¡ç®—

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusAsciiAduParserTests.cs`
- **æµ‹è¯•å†…å®¹**:
  - æµ‹è¯•ä» ASCII ADU ä¸­æå– PDU
  - æµ‹è¯• LRC éªŒè¯
  - æµ‹è¯•å¼‚å¸¸å¸§çš„å¤„ç†

#### **æ­¥éª¤ 8: ç¼–å†™é›†æˆæµ‹è¯•å’Œç¤ºä¾‹ä»£ç **

- **æ–‡ä»¶ä¿®æ”¹**: `samples/ZHIOT.Modbus.Sample/Program.cs`
- **éœ€è¦çš„å˜æ›´**:
  - æ·»åŠ  `RunModbusAsciiSample()` æ–¹æ³•
  - æ¼”ç¤º ASCII å®¢æˆ·ç«¯çš„åŸºæœ¬ä½¿ç”¨
  - å±•ç¤ºä¸ RTU çš„ä¸»è¦åŒºåˆ«

#### **æ­¥éª¤ 9: æ›´æ–°æ–‡æ¡£**

- **æ–‡ä»¶ä¿®æ”¹**: `README.md`
- **éœ€è¦çš„å˜æ›´**:
  - åœ¨"ç‰¹æ€§"éƒ¨åˆ†æ·»åŠ  Modbus ASCII æ”¯æŒ
  - åœ¨"å¿«é€Ÿå¼€å§‹"éƒ¨åˆ†æ·»åŠ  ASCII ä½¿ç”¨ç¤ºä¾‹
  - æ›´æ–°é¡¹ç›®ç»“æ„éƒ¨åˆ†
  - åœ¨"è·¯çº¿å›¾"ä¸­æ ‡è®° ASCII ä¸ºå·²å®Œæˆ

#### **æ­¥éª¤ 10: ç¼–è¯‘å¹¶ä¿®å¤é”™è¯¯**

- è¿è¡Œ `dotnet build` ç¼–è¯‘æ•´ä¸ªè§£å†³æ–¹æ¡ˆ
- æ£€æŸ¥æ˜¯å¦æœ‰ç¼–è¯‘é”™è¯¯
- ä¿®å¤æ‰€æœ‰é”™è¯¯

#### **æ­¥éª¤ 11: è¿è¡Œå•å…ƒæµ‹è¯•**

- è¿è¡Œ `dotnet test` æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
- éªŒè¯æ‰€æœ‰ç°æœ‰æµ‹è¯•ç»§ç»­é€šè¿‡
- éªŒè¯æ–°å¢çš„ ASCII æµ‹è¯•å…¨éƒ¨é€šè¿‡

#### **æ­¥éª¤ 12: æ‰‹åŠ¨æµ‹è¯•**

- ä½¿ç”¨ Modbus ASCII æ¨¡æ‹Ÿå™¨æµ‹è¯•
- æµ‹è¯•çœŸå®çš„ Modbus ASCII è®¾å¤‡
- éªŒè¯ç¤ºä¾‹ä»£ç æ­£å¸¸å·¥ä½œ

### æµ‹è¯•ç­–ç•¥

#### å•å…ƒæµ‹è¯•
1. **ModbusLrcTests.cs**: LRC è®¡ç®—å’ŒéªŒè¯
2. **ModbusAsciiCodecTests.cs**: ASCII ç¼–è§£ç 
3. **ModbusAsciiAduBuilderTests.cs**: ADU æ„å»º
4. **ModbusAsciiAduParserTests.cs**: ADU è§£æ

#### é›†æˆæµ‹è¯•
- ä½¿ç”¨ Modbus ASCII æ¨¡æ‹Ÿå™¨ï¼ˆå¦‚ Modbus Slaveï¼‰
- æµ‹è¯•æ‰€æœ‰æ”¯æŒçš„åŠŸèƒ½ç 
- æµ‹è¯•æ‰©å±•æ•°æ®ç±»å‹
- æµ‹è¯• 1 åŸºåœ°å€æ¨¡å¼

#### æ‰‹åŠ¨æµ‹è¯•
- è¿æ¥çœŸå®è®¾å¤‡
- æµ‹è¯•å„ç§æ³¢ç‰¹ç‡å’Œå¥‡å¶æ ¡éªŒé…ç½®
- éªŒè¯æ–‡æ¡£å‡†ç¡®æ€§

### å®ç°æŒ‡å—

#### å‰ç«¯å®ç°
- **å¼ºåˆ¶è¦æ±‚ï¼šå®ç°å‰æœç´¢** - åœ¨å®ç°ä»»ä½•ä»£ç å‰ï¼Œå¿…é¡»æœç´¢ä»£ç åº“æŸ¥æ‰¾ç›¸ä¼¼çš„å®ç°
  - ä½¿ç”¨ `grep_search` æˆ– `semantic_search` æŸ¥æ‰¾ç›¸å…³çš„ APIã€æ–¹æ³•å’Œå·¥å…·
  - ç ”ç©¶ç°æœ‰ä»£ç çš„å‘½åæ¨¡å¼å’Œç»“æ„
  - ç¡®ä¿æ–°ä»£ç éµå¾ªç°æœ‰é£æ ¼
  - ç¤ºä¾‹æœç´¢å…³é”®è¯ï¼šPDU æ„å»ºã€ADU è§£æã€ç¼–ç è§£ç 
  - **ç¦æ­¢**å‡­ç©ºçŒœæµ‹ - æ€»æ˜¯å…ˆæŸ¥è¯ç°æœ‰ä»£ç 

#### åç«¯å®ç°
- **å¼ºåˆ¶è¦æ±‚ï¼šç¼–è¯‘å¹¶è¿­ä»£ä¿®å¤** - å®Œæˆåç«¯ä»£ç åå¿…é¡»ç¼–è¯‘å¹¶ä¿®å¤æ‰€æœ‰é”™è¯¯
  - æ­¥éª¤ 1: ä¿®æ”¹ä»£ç åç«‹å³è¿è¡Œç¼–è¯‘éªŒè¯
  - æ­¥éª¤ 2: ä½¿ç”¨å·¥å…·æ£€æŸ¥ç¼–è¯‘é”™è¯¯
  - æ­¥éª¤ 3: æ ¹æ®é”™è¯¯æ¶ˆæ¯ä¿®å¤é—®é¢˜
  - æ­¥éª¤ 4: é‡å¤ç›´åˆ°ç¼–è¯‘æˆåŠŸæ— é”™è¯¯
  - æ­¥éª¤ 5: ç¡®ä¿æ‰€æœ‰è­¦å‘Šéƒ½å·²ä¿®å¤æˆ–æœ‰æ–‡æ¡£è¯´æ˜
  - ç¼–è¯‘å‘½ä»¤: `dotnet build d:\WorkSpace\OpenSource\ZHIOT.Modbus\ZHIOT.Modbus.sln`
  - **ç¦æ­¢**åœ¨ç¼–è¯‘å‰è®¤ä¸ºå®Œæˆ

## âœ¨ æˆåŠŸæ ‡å‡†

### åŠŸèƒ½å®Œæ•´æ€§
- âœ… æ”¯æŒæ‰€æœ‰æ ‡å‡† Modbus åŠŸèƒ½ç ï¼ˆ0x01-0x06, 0x0F, 0x10ï¼‰
- âœ… å®Œæ•´çš„ LRC-8 æ ¡éªŒå®ç°
- âœ… ASCII ç¼–è§£ç å·¥å…·å®Œæ•´å¯ç”¨
- âœ… ä¸ TCP/RTU å…±äº«ç›¸åŒçš„ `IModbusClient` æ¥å£
- âœ… æ”¯æŒæ‰€æœ‰æ‰©å±•æ•°æ®ç±»å‹ï¼ˆfloat, double, int32, uint32, byte[]ï¼‰
- âœ… æ”¯æŒå­—èŠ‚åºé…ç½®å’Œ 1 åŸºåœ°å€æ¨¡å¼

### æ€§èƒ½æ ‡å‡†
- âœ… LRC è®¡ç®—æ€§èƒ½æ— æ˜¾è‘—ä¸‹é™
- âœ… ASCII ç¼–è§£ç ä½¿ç”¨é›¶åˆ†é…æˆ–æœ€å°åˆ†é…
- âœ… ä½¿ç”¨ `Span<T>` å’Œ `Memory<T>` å¤„ç†åè®®æ“ä½œ
- âœ… å¸§è¾¹ç•Œæ£€æµ‹é«˜æ•ˆå‡†ç¡®

### ä»£ç è´¨é‡
- âœ… éµå¾ªç°æœ‰ä»£ç é£æ ¼å’Œå‘½åçº¦å®š
- âœ… æ‰€æœ‰å…¬å…± API æœ‰å®Œæ•´çš„ XML æ–‡æ¡£æ³¨é‡Š
- âœ… å…³é”®é€»è¾‘æœ‰æ¸…æ™°çš„ä»£ç æ³¨é‡Š
- âœ… æ— ç¼–è¯‘è­¦å‘Š
- âœ… é€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### æ–‡æ¡£å®Œæ•´æ€§
- âœ… README.md åŒ…å« ASCII ä½¿ç”¨ç¤ºä¾‹
- âœ… ASCII åè®®ç‰¹ç‚¹æœ‰æ¸…æ™°è¯´æ˜
- âœ… æä¾›å®Œæ•´çš„ç¤ºä¾‹ä»£ç 
- âœ… æ›´æ–°æ¶æ„æ–‡æ¡£

### å…¼å®¹æ€§
- âœ… ä¸ç°æœ‰ TCP/RTU å®ç°å…±äº«æ ¸å¿ƒç»„ä»¶
- âœ… ä¸ç ´åç°æœ‰ API çš„å‘åå…¼å®¹æ€§
- âœ… æ”¯æŒ .NET 8.0 å’Œæ›´é«˜ç‰ˆæœ¬
- âœ… éµå¾ª Modbus ASCII å®˜æ–¹è§„èŒƒ

### æµ‹è¯•è¦†ç›–ç‡
- âœ… LRC ç®—æ³•å•å…ƒæµ‹è¯•è¦†ç›–ç‡ 100%
- âœ… ASCII ç¼–è§£ç å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- âœ… ADU æ„å»º/è§£æå•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- âœ… ä¸ Modbus ASCII æ¨¡æ‹Ÿå™¨çš„é›†æˆæµ‹è¯•é€šè¿‡
- âœ… æ‰€æœ‰åŠŸèƒ½ç å’Œæ•°æ®ç±»å‹çš„ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡

