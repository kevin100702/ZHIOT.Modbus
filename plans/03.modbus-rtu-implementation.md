# Feature Implementation Plan: modbus-rtu-implementation

## âœ… Todo Checklist
- [ ] å®šä¹‰ Modbus RTU æ ¸å¿ƒç±»å‹å’Œå¸¸é‡
- [ ] å®ç° CRC16 æ ¡éªŒç®—æ³•
- [ ] åˆ›å»ºä¸²å£ä¼ è¾“å±‚ (SerialPortTransport)
- [ ] å®ç° Modbus RTU ADU æ„å»ºå™¨å’Œè§£æå™¨
- [ ] å®ç° ModbusRtuClient å®¢æˆ·ç«¯
- [ ] æ‰©å±• ModbusClientFactory æ”¯æŒ RTU å®¢æˆ·ç«¯åˆ›å»º
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] ç¼–å†™é›†æˆæµ‹è¯•å’Œç¤ºä¾‹ä»£ç 
- [ ] æœ€ç»ˆå®¡æŸ¥å’Œæµ‹è¯•

## ğŸ” Analysis & Investigation

### Codebase Structure

å½“å‰é¡¹ç›®å…·æœ‰æ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼Œå·²æˆåŠŸå®ç°äº† Modbus TCP åè®®ã€‚é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š

```
src/ZHIOT.Modbus/
â”œâ”€â”€ Abstractions/          # æ ¸å¿ƒæŠ½è±¡æ¥å£
â”‚   â”œâ”€â”€ IModbusClient.cs   # å®¢æˆ·ç«¯æ¥å£ï¼Œå®šä¹‰æ‰€æœ‰ Modbus æ“ä½œ
â”‚   â””â”€â”€ ITransport.cs      # ä¼ è¾“å±‚æ¥å£ï¼ŒåŸºäº IDuplexPipe
â”œâ”€â”€ Core/                  # åè®®æ ¸å¿ƒå®ç°
â”‚   â”œâ”€â”€ ModbusPduBuilder.cs    # PDU æ„å»ºå™¨ï¼ˆåŠŸèƒ½ç  + æ•°æ®ï¼‰
â”‚   â”œâ”€â”€ ModbusPduParser.cs     # PDU è§£æå™¨
â”‚   â”œâ”€â”€ ModbusTypes.cs         # åŠŸèƒ½ç ã€å¼‚å¸¸ç ã€MBAP å¤´å®šä¹‰
â”‚   â””â”€â”€ ByteOrder.cs           # å­—èŠ‚åºæšä¸¾
â”œâ”€â”€ Client/                # å®¢æˆ·ç«¯å®ç°
â”‚   â””â”€â”€ ModbusTcpClient.cs # TCP å®¢æˆ·ç«¯å®ç°
â”œâ”€â”€ Transport/             # ä¼ è¾“å±‚å®ç°
â”‚   â””â”€â”€ TcpTransport.cs    # åŸºäº Socket å’Œ Pipelines çš„ TCP ä¼ è¾“
â”œâ”€â”€ Utils/                 # å·¥å…·ç±»
â”‚   â””â”€â”€ ModbusDataConverter.cs # é«˜æ€§èƒ½æ•°æ®ç±»å‹è½¬æ¢å™¨
â””â”€â”€ ModbusClientFactory.cs # å®¢æˆ·ç«¯å·¥å‚
```

**å…³é”®å‘ç°**ï¼š
1. é¡¹ç›®é‡‡ç”¨æ¥å£é©±åŠ¨è®¾è®¡ï¼Œ`ITransport` å’Œ `IModbusClient` çš„æŠ½è±¡ä½¿å¾—åè®®å±‚ä¸ä¼ è¾“å±‚å®Œå…¨è§£è€¦
2. ç°æœ‰çš„ `ModbusPduBuilder` å’Œ `ModbusPduParser` åªå¤„ç† PDUï¼ˆåè®®æ•°æ®å•å…ƒï¼‰ï¼Œä¸åŒ…å«ä¼ è¾“å±‚ç‰¹å®šçš„å¸§å¤´å’Œæ ¡éªŒ
3. `ModbusTcpClient` è´Ÿè´£æ·»åŠ  MBAP å¤´å¹¶é€šè¿‡ `ITransport` å‘é€/æ¥æ”¶å®Œæ•´çš„ ADU
4. ä½¿ç”¨ `System.IO.Pipelines` å®ç°é«˜æ€§èƒ½å¼‚æ­¥ I/O
5. å…¨é¢ä½¿ç”¨ `Span<T>` å’Œ `Memory<T>` å®ç°é›¶æ‹·è´æˆ–æœ€å°åˆ†é…

### Current Architecture

**ç°æœ‰ TCP æ¶æ„**ï¼š
```
ModbusTcpClient (åº”ç”¨å±‚)
    â†“
    æ„å»º: [MBAP Header (7 bytes)] + [PDU]
    â†“
TcpTransport (ä¼ è¾“å±‚ - IDuplexPipe)
    â†“
Socket/NetworkStream â†’ Pipelines
```

**TCP ADU ç»“æ„**ï¼š
```
[Transaction ID (2)] [Protocol ID (2)] [Length (2)] [Unit ID (1)] [PDU]
         MBAP Header (7 bytes)                        å¯å˜é•¿åº¦
```

**ç›®æ ‡ RTU æ¶æ„**ï¼š
```
ModbusRtuClient (åº”ç”¨å±‚)
    â†“
    æ„å»º: [Slave ID (1)] + [PDU] + [CRC16 (2)]
    â†“
SerialPortTransport (ä¼ è¾“å±‚ - IDuplexPipe)
    â†“
SerialPort â†’ Pipelines
```

**RTU ADU ç»“æ„**ï¼š
```
[Slave ID (1)] [Function Code (1)] [Data (N)] [CRC Low (1)] [CRC High (1)]
       RTU ADU = Slave ID + PDU + CRC16
```

### Dependencies & Integration Points

**æ–°å¢ä¾èµ–**ï¼š
1. **System.IO.Ports** - .NET å®˜æ–¹ä¸²å£é€šä¿¡åº“ï¼ˆé€‚ç”¨äº .NET 6+ å’Œ .NET Standard 2.1+ï¼‰
2. **ç°æœ‰ä¾èµ–ä¿æŒä¸å˜**ï¼š
   - System.IO.Pipelines (å·²æœ‰)
   - System.Memory (å·²æœ‰)

**é›†æˆç‚¹**ï¼š
1. **å…±äº« PDU å±‚** - `ModbusPduBuilder` å’Œ `ModbusPduParser` å¯ä»¥è¢« TCP å’Œ RTU å…±ç”¨
2. **å…±äº«æ¥å£** - `IModbusClient` æ¥å£å¯¹ TCP å’Œ RTU éƒ½é€‚ç”¨
3. **å…±äº«æ•°æ®è½¬æ¢å™¨** - `ModbusDataConverter` å¯è¢«ä¸¤ç§åè®®å¤ç”¨
4. **æ‰©å±•å·¥å‚** - `ModbusClientFactory` éœ€è¦æ·»åŠ åˆ›å»º RTU å®¢æˆ·ç«¯çš„æ–¹æ³•

### Considerations & Challenges

**å…³é”®æŠ€æœ¯æŒ‘æˆ˜**ï¼š

1. **å¸§è¾¹ç•Œæ£€æµ‹å·®å¼‚**
   - **TCP**: åŸºäº MBAP å¤´ä¸­çš„ Length å­—æ®µï¼Œæ˜ç¡®çŸ¥é“æ¶ˆæ¯é•¿åº¦
   - **RTU**: ä¾èµ–"é™é»˜æœŸ"ï¼ˆ3.5 ä¸ªå­—ç¬¦æ—¶é—´ï¼‰æ¥åˆ†éš”å¸§ï¼Œè¿™åœ¨é«˜é€Ÿå¼‚æ­¥ I/O ä¸­è¾ƒéš¾å®ç°
   - **è§£å†³æ–¹æ¡ˆ**: åŸºäº CRC æ ¡éªŒå’Œè¶…æ—¶æœºåˆ¶æ¥æ£€æµ‹å®Œæ•´å¸§

2. **ä¸²å£é€šä¿¡ç‰¹æ€§**
   - ä¸²å£æ˜¯å…¨åŒå·¥ä½†é€šå¸¸æ˜¯åŠåŒå·¥ä½¿ç”¨ï¼ˆä¸€æ¬¡åªèƒ½ä¸€ä¸ªæ–¹å‘é€šä¿¡ï¼‰
   - éœ€è¦è€ƒè™‘æ³¢ç‰¹ç‡ã€æ•°æ®ä½ã€åœæ­¢ä½ã€æ ¡éªŒä½ç­‰é…ç½®
   - RTU å¯¹æ—¶åºè¦æ±‚ä¸¥æ ¼ï¼Œå¸§é—´å¿…é¡»æœ‰ 3.5 å­—ç¬¦æ—¶é—´çš„é™é»˜æœŸ

3. **CRC16 æ ¡éªŒ**
   - RTU ä½¿ç”¨ CRC-16/MODBUS ç®—æ³•ï¼ˆå¤šé¡¹å¼ 0xA001ï¼Œåˆå€¼ 0xFFFFï¼‰
   - éœ€è¦é«˜æ€§èƒ½å®ç°ï¼Œé¿å…å½±å“æ•´ä½“ååé‡
   - CRC å­—èŠ‚åºä¸ºå°ç«¯ï¼ˆä½å­—èŠ‚åœ¨å‰ï¼‰

4. **é”™è¯¯å¤„ç†**
   - ä¸²å£é€šä¿¡æ›´å®¹æ˜“å‡ºç°ä¼ è¾“é”™è¯¯
   - éœ€è¦æ›´å¼ºçš„è¶…æ—¶å’Œé‡è¯•æœºåˆ¶
   - CRC æ ¡éªŒå¤±è´¥çš„å¤„ç†

5. **æ€§èƒ½ä¼˜åŒ–**
   - ä¿æŒä¸ç°æœ‰ TCP å®ç°ç›¸åŒçš„é›¶æ‹·è´ã€ä½åˆ†é…è®¾è®¡ç†å¿µ
   - ä½¿ç”¨ `Span<T>` è¿›è¡Œ CRC è®¡ç®—
   - åˆ©ç”¨ Pipelines é«˜æ•ˆå¤„ç†ä¸²å£æ•°æ®æµ

**åè®®å·®å¼‚æ€»ç»“**ï¼š

| ç‰¹æ€§ | Modbus TCP | Modbus RTU |
|------|-----------|-----------|
| ä¼ è¾“ä»‹è´¨ | ä»¥å¤ªç½‘ | ä¸²å£ (RS-232/RS-485/RS-422) |
| å¸§å¤´ | MBAP Header (7 bytes) | Slave ID (1 byte) |
| æ ¡éªŒ | TCP å±‚ä¿è¯ | CRC-16 (2 bytes) |
| å¸§è¾¹ç•Œ | åŸºäºé•¿åº¦å­—æ®µ | åŸºäºé™é»˜æœŸå’Œ CRC |
| å­—èŠ‚åº | å¤§ç«¯ | å¤§ç«¯ |
| PDU | ç›¸åŒ | ç›¸åŒ |

## ğŸ“‹ Implementation Plan

### Prerequisites

- .NET 8 SDKï¼ˆå·²æœ‰ï¼‰
- System.IO.Ports NuGet åŒ…ï¼ˆéœ€è¦æ·»åŠ ï¼‰
- ç°æœ‰çš„é¡¹ç›®ç»“æ„å’Œä¾èµ–ï¼ˆå·²å°±ç»ªï¼‰

### Step-by-Step Implementation

#### **æ­¥éª¤ 1: å®šä¹‰ RTU æ ¸å¿ƒç±»å‹**
- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusRtuTypes.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  // å®šä¹‰ RTU ADU ç»“æ„
  public readonly struct RtuAdu
  {
      public byte SlaveId { get; init; }
      public ReadOnlyMemory<byte> Pdu { get; init; }
      public ushort Crc { get; init; }
      public const int MinSize = 4; // SlaveId + FunctionCode + CRC
  }
  
  // å®šä¹‰ä¸²å£é…ç½®
  public class SerialPortSettings
  {
      public string PortName { get; set; } = "COM1";
      public int BaudRate { get; set; } = 9600;
      public Parity Parity { get; set; } = Parity.None;
      public int DataBits { get; set; } = 8;
      public StopBits StopBits { get; set; } = StopBits.One;
      public int ReadTimeout { get; set; } = 1000;
      public int WriteTimeout { get; set; } = 1000;
  }
  ```

#### **æ­¥éª¤ 2: å®ç° CRC16 æ ¡éªŒç®—æ³•**
- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusCrc16.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public static class ModbusCrc16
  {
      // ä½¿ç”¨æŸ¥è¡¨æ³•å®ç°é«˜æ€§èƒ½ CRC-16/MODBUS è®¡ç®—
      private static readonly ushort[] CrcTable = GenerateCrcTable();
      
      public static ushort Calculate(ReadOnlySpan<byte> data)
      {
          // å®ç° CRC-16/MODBUS ç®—æ³•
          // å¤šé¡¹å¼: 0xA001 (åå‘)
          // åˆå§‹å€¼: 0xFFFF
          // æœ€ç»ˆå¼‚æˆ–: 0x0000
      }
      
      public static bool Verify(ReadOnlySpan<byte> frame)
      {
          // éªŒè¯å¸§çš„ CRCï¼ˆæœ€åä¸¤å­—èŠ‚ï¼‰
      }
      
      private static ushort[] GenerateCrcTable()
      {
          // ç”Ÿæˆ CRC æŸ¥æ‰¾è¡¨
      }
  }
  ```
- **æ€§èƒ½è¦æ±‚**: ä½¿ç”¨æŸ¥è¡¨æ³•ï¼Œå¤„ç†é€Ÿåº¦åº”è¾¾åˆ° > 100 MB/s

#### **æ­¥éª¤ 3: åˆ›å»º RTU ADU æ„å»ºå™¨å’Œè§£æå™¨**
- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusRtuAduBuilder.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public static class ModbusRtuAduBuilder
  {
      // æ„å»ºå®Œæ•´çš„ RTU ADU (SlaveId + PDU + CRC)
      public static int BuildAdu(Span<byte> buffer, byte slaveId, ReadOnlySpan<byte> pdu)
      {
          buffer[0] = slaveId;
          pdu.CopyTo(buffer.Slice(1));
          int frameLength = 1 + pdu.Length;
          
          // è®¡ç®—å¹¶æ·»åŠ  CRC
          var crc = ModbusCrc16.Calculate(buffer.Slice(0, frameLength));
          BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(frameLength), crc);
          
          return frameLength + 2; // +2 for CRC
      }
  }
  ```

- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Core/ModbusRtuAduParser.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public static class ModbusRtuAduParser
  {
      // ä»å®Œæ•´çš„ RTU ADU ä¸­æå– PDU
      public static ReadOnlySpan<byte> ExtractPdu(ReadOnlySpan<byte> adu)
      {
          // éªŒè¯æœ€å°é•¿åº¦
          if (adu.Length < RtuAdu.MinSize)
              throw new InvalidOperationException("ADU too short");
          
          // éªŒè¯ CRC
          if (!ModbusCrc16.Verify(adu))
              throw new InvalidOperationException("CRC verification failed");
          
          // è¿”å› PDU éƒ¨åˆ†ï¼ˆè·³è¿‡ SlaveIdï¼Œå»é™¤ CRCï¼‰
          return adu.Slice(1, adu.Length - 3);
      }
  }
  ```

#### **æ­¥éª¤ 4: å®ç°ä¸²å£ä¼ è¾“å±‚**
- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Transport/SerialPortTransport.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public class SerialPortTransport : ITransport
  {
      private readonly SerialPortSettings _settings;
      private SerialPort? _serialPort;
      private IDuplexPipe? _pipe;
      private CancellationTokenSource? _readLoopCts;
      
      public SerialPortTransport(SerialPortSettings settings)
      {
          _settings = settings;
      }
      
      public async Task ConnectAsync(CancellationToken cancellationToken = default)
      {
          // 1. åˆ›å»ºå¹¶é…ç½® SerialPort
          // 2. æ‰“å¼€ä¸²å£
          // 3. åˆ›å»º Pipe å¹¶å¯åŠ¨è¯»å–å¾ªç¯
          // 4. ä½¿ç”¨åå°ä»»åŠ¡å°†ä¸²å£æ•°æ®æ³µå…¥ PipeWriter
      }
      
      public async Task CloseAsync(CancellationToken cancellationToken = default)
      {
          // æ¸…ç†èµ„æº
      }
      
      private async Task ReadLoopAsync()
      {
          // æŒç»­ä»ä¸²å£è¯»å–æ•°æ®å¹¶å†™å…¥ PipeWriter
      }
      
      // IDuplexPipe åŒ…è£…ï¼Œä½¿ PipeWriter å†™å…¥ä¸²å£
  }
  ```
- **å…³é”®å®ç°ç»†èŠ‚**:
  - ä½¿ç”¨ `PipeWriter` ç¼“å†²ä¸²å£è¾“å…¥æ•°æ®
  - ä½¿ç”¨ `PipeReader` è¯»å–è¦å‘é€çš„æ•°æ®å¹¶å†™å…¥ä¸²å£
  - æ­£ç¡®å¤„ç†ä¸²å£çš„æ‰“å¼€/å…³é—­ç”Ÿå‘½å‘¨æœŸ
  - å®ç°è¶…æ—¶æœºåˆ¶

#### **æ­¥éª¤ 5: å®ç° ModbusRtuClient**
- **æ–‡ä»¶åˆ›å»º**: `src/ZHIOT.Modbus/Client/ModbusRtuClient.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public class ModbusRtuClient : IModbusClient
  {
      private readonly ITransport _transport;
      private readonly SemaphoreSlim _sendLock = new(1, 1);
      
      // å®ç°ä¸ ModbusTcpClient ç›¸ä¼¼ï¼Œä½†ä½¿ç”¨ RTU ADU
      
      private async Task<byte[]> SendRequestAsync(byte slaveId, byte[] pdu, CancellationToken cancellationToken)
      {
          await _sendLock.WaitAsync(cancellationToken);
          try
          {
              // 1. æ„å»º RTU ADU (SlaveId + PDU + CRC)
              var adu = new byte[1 + pdu.Length + 2];
              ModbusRtuAduBuilder.BuildAdu(adu, slaveId, pdu);
              
              // 2. å‘é€è¯·æ±‚
              var output = _transport.Pipe.Output;
              var memory = output.GetMemory(adu.Length);
              adu.CopyTo(memory.Span);
              output.Advance(adu.Length);
              await output.FlushAsync(cancellationToken);
              
              // 3. æ¥æ”¶å“åº”
              var input = _transport.Pipe.Input;
              while (true)
              {
                  var result = await input.ReadAsync(cancellationToken);
                  var buffer = result.Buffer;
                  
                  if (TryParseResponse(ref buffer, slaveId, out var responsePdu))
                  {
                      input.AdvanceTo(buffer.Start);
                      return responsePdu;
                  }
                  
                  input.AdvanceTo(buffer.Start, buffer.End);
                  
                  if (result.IsCompleted)
                      throw new IOException("Connection closed");
              }
          }
          finally
          {
              _sendLock.Release();
          }
      }
      
      private bool TryParseResponse(ref ReadOnlySequence<byte> buffer, byte expectedSlaveId, out byte[] pdu)
      {
          // 1. æ£€æŸ¥æœ€å°é•¿åº¦
          // 2. æŸ¥æ‰¾å®Œæ•´å¸§ï¼ˆåŸºäºé¢„æœŸé•¿åº¦æˆ–è¶…æ—¶ï¼‰
          // 3. éªŒè¯ CRC
          // 4. éªŒè¯ SlaveId
          // 5. æå– PDU
      }
      
      // å¤ç”¨ ModbusTcpClient çš„æ‰€æœ‰ä¸šåŠ¡æ–¹æ³•å®ç°
      // ï¼ˆReadCoilsAsync, ReadHoldingRegistersAsync ç­‰ï¼‰
  }
  ```
- **å…³é”®è®¾è®¡ç‚¹**:
  - å®Œå…¨å¤ç”¨ `ModbusPduBuilder` å’Œ `ModbusPduParser`
  - ä¸ `ModbusTcpClient` çš„ä¸»è¦åŒºåˆ«åœ¨äº ADU çš„å°è£…å’Œè§£å°è£…
  - å¸§è¾¹ç•Œæ£€æµ‹é€»è¾‘ï¼šå…ˆæ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿå­—èŠ‚ï¼ˆæ ¹æ®åŠŸèƒ½ç æ¨æ–­ï¼‰ï¼Œç„¶åéªŒè¯ CRC

#### **æ­¥éª¤ 6: æ‰©å±•å®¢æˆ·ç«¯å·¥å‚**
- **æ–‡ä»¶ä¿®æ”¹**: `src/ZHIOT.Modbus/ModbusClientFactory.cs`
- **éœ€è¦çš„å˜æ›´**:
  ```csharp
  public static class ModbusClientFactory
  {
      public static IModbusClient CreateTcpClient(string host, int port = 502)
      {
          // ç°æœ‰å®ç°ä¿æŒä¸å˜
      }
      
      // æ–°å¢æ–¹æ³•
      public static IModbusClient CreateRtuClient(SerialPortSettings settings)
      {
          var transport = new SerialPortTransport(settings);
          return new ModbusRtuClient(transport);
      }
      
      // ä¾¿æ·é‡è½½
      public static IModbusClient CreateRtuClient(
          string portName, 
          int baudRate = 9600,
          Parity parity = Parity.None,
          int dataBits = 8,
          StopBits stopBits = StopBits.One)
      {
          var settings = new SerialPortSettings
          {
              PortName = portName,
              BaudRate = baudRate,
              Parity = parity,
              DataBits = dataBits,
              StopBits = stopBits
          };
          return CreateRtuClient(settings);
      }
  }
  ```

#### **æ­¥éª¤ 7: æ›´æ–°é¡¹ç›®é…ç½®**
- **æ–‡ä»¶ä¿®æ”¹**: `src/ZHIOT.Modbus/ZHIOT.Modbus.csproj`
- **éœ€è¦çš„å˜æ›´**:
  ```xml
  <ItemGroup>
    <PackageReference Include="System.IO.Pipelines" Version="9.0.10" />
    <PackageReference Include="System.IO.Ports" Version="8.0.0" />
  </ItemGroup>
  ```

#### **æ­¥éª¤ 8: ç¼–å†™å•å…ƒæµ‹è¯•**
- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusCrc16Tests.cs`
- **æµ‹è¯•å†…å®¹**:
  ```csharp
  [TestClass]
  public class ModbusCrc16Tests
  {
      [TestMethod]
      public void Calculate_ValidFrame_ReturnsCorrectCrc()
      {
          // ä½¿ç”¨å·²çŸ¥çš„ Modbus RTU å¸§éªŒè¯ CRC è®¡ç®—
          // ç¤ºä¾‹: 01 03 00 00 00 0A -> CRC: 0xC5CD
      }
      
      [TestMethod]
      public void Verify_ValidFrame_ReturnsTrue()
      {
          // éªŒè¯åŒ…å«æ­£ç¡® CRC çš„å¸§
      }
      
      [TestMethod]
      public void Verify_InvalidCrc_ReturnsFalse()
      {
          // éªŒè¯ CRC é”™è¯¯çš„å¸§
      }
  }
  ```

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusRtuAduBuilderTests.cs`
- **æµ‹è¯•å†…å®¹**:
  ```csharp
  [TestClass]
  public class ModbusRtuAduBuilderTests
  {
      [TestMethod]
      public void BuildAdu_ValidPdu_ReturnsCompleteFrame()
      {
          // æµ‹è¯• ADU æ„å»ºçš„æ­£ç¡®æ€§
      }
  }
  ```

- **æ–‡ä»¶åˆ›å»º**: `tests/ZHIOT.Modbus.Tests/ModbusRtuAduParserTests.cs`
- **æµ‹è¯•å†…å®¹**:
  ```csharp
  [TestClass]
  public class ModbusRtuAduParserTests
  {
      [TestMethod]
      public void ExtractPdu_ValidAdu_ReturnsPdu()
      {
          // æµ‹è¯•ä»å®Œæ•´ ADU ä¸­æå– PDU
      }
      
      [TestMethod]
      public void ExtractPdu_InvalidCrc_ThrowsException()
      {
          // æµ‹è¯• CRC æ ¡éªŒå¤±è´¥çš„æƒ…å†µ
      }
  }
  ```

#### **æ­¥éª¤ 9: ç¼–å†™ç¤ºä¾‹ä»£ç **
- **æ–‡ä»¶åˆ›å»º**: `samples/ZHIOT.Modbus.Sample/RtuSample.cs`
- **ç¤ºä¾‹å†…å®¹**:
  ```csharp
  public static async Task RunModbusRtuSample()
  {
      Console.WriteLine("=== Modbus RTU ç¤ºä¾‹ ===");
      
      // åˆ›å»º RTU å®¢æˆ·ç«¯
      await using var client = ModbusClientFactory.CreateRtuClient(
          portName: "COM1",
          baudRate: 9600,
          parity: Parity.None,
          dataBits: 8,
          stopBits: StopBits.One
      );
      
      try
      {
          // è¿æ¥ä¸²å£
          await client.ConnectAsync();
          Console.WriteLine("ä¸²å£å·²æ‰“å¼€");
          
          byte slaveId = 1;
          
          // è¯»å–ä¿æŒå¯„å­˜å™¨
          var registers = await client.ReadHoldingRegistersAsync(
              slaveId, 
              startAddress: 0, 
              quantity: 10
          );
          
          Console.WriteLine($"è¯»å–åˆ° {registers.Length} ä¸ªå¯„å­˜å™¨:");
          foreach (var reg in registers)
          {
              Console.WriteLine($"  {reg}");
          }
          
          // å†™å…¥å¯„å­˜å™¨
          await client.WriteSingleRegisterAsync(slaveId, 0, 1234);
          Console.WriteLine("å†™å…¥æˆåŠŸ");
          
          await client.DisconnectAsync();
      }
      catch (Exception ex)
      {
          Console.WriteLine($"é”™è¯¯: {ex.Message}");
      }
  }
  ```

#### **æ­¥éª¤ 10: æ›´æ–°æ–‡æ¡£**
- **æ–‡ä»¶ä¿®æ”¹**: `README.md`
- **éœ€è¦çš„å˜æ›´**:
  - åœ¨"ç‰¹æ€§"éƒ¨åˆ†æ·»åŠ "âœ… **Modbus RTU**: å®Œæ•´çš„ Modbus RTU ä¸²å£é€šä¿¡å®ç°"
  - åœ¨"å¿«é€Ÿå¼€å§‹"éƒ¨åˆ†æ·»åŠ  RTU ä½¿ç”¨ç¤ºä¾‹
  - æ·»åŠ "ä¸²å£é…ç½®"ç« èŠ‚
  - æ›´æ–°"é¡¹ç›®ç»“æ„"ç« èŠ‚
  - åœ¨"è·¯çº¿å›¾"ä¸­æ ‡è®° RTU ä¸ºå·²å®Œæˆ

### Testing Strategy

#### å•å…ƒæµ‹è¯•
1. **CRC16 ç®—æ³•æµ‹è¯•**
   - ä½¿ç”¨ Modbus å®˜æ–¹è§„èŒƒä¸­çš„æµ‹è¯•å‘é‡
   - æµ‹è¯•è¾¹ç•Œæ¡ä»¶ï¼ˆç©ºæ•°æ®ã€å•å­—èŠ‚ã€å¤§æ•°æ®ï¼‰
   - æ€§èƒ½åŸºå‡†æµ‹è¯•

2. **ADU æ„å»ºå’Œè§£ææµ‹è¯•**
   - æµ‹è¯•å„ç§åŠŸèƒ½ç çš„ ADU æ„å»º
   - æµ‹è¯• CRC æ ¡éªŒçš„æ­£ç¡®æ€§
   - æµ‹è¯•å¼‚å¸¸å¸§çš„å¤„ç†

3. **ä¸²å£ä¼ è¾“å±‚æ¨¡æ‹Ÿæµ‹è¯•**
   - ä½¿ç”¨è™šæ‹Ÿä¸²å£å¯¹ï¼ˆloopbackï¼‰è¿›è¡Œæµ‹è¯•
   - æµ‹è¯•è¿æ¥ã€æ–­å¼€ã€é‡è¿é€»è¾‘
   - æµ‹è¯•è¶…æ—¶å¤„ç†

#### é›†æˆæµ‹è¯•
1. **ç«¯åˆ°ç«¯é€šä¿¡æµ‹è¯•**
   - ä½¿ç”¨ Modbus RTU æ¨¡æ‹Ÿå™¨ï¼ˆå¦‚ Modbus Slaveï¼‰
   - æµ‹è¯•æ‰€æœ‰æ”¯æŒçš„åŠŸèƒ½ç 
   - æµ‹è¯•æ‰©å±•æ•°æ®ç±»å‹çš„è¯»å†™
   - æµ‹è¯• 1 åŸºåœ°å€æ¨¡å¼

2. **é”™è¯¯åœºæ™¯æµ‹è¯•**
   - CRC é”™è¯¯
   - è¶…æ—¶
   - ä¸²å£æ–­å¼€
   - å¼‚å¸¸å“åº”

3. **æ€§èƒ½æµ‹è¯•**
   - é«˜é¢‘è¯»å†™æµ‹è¯•
   - å†…å­˜åˆ†é…åˆ†æ
   - ååé‡æµ‹è¯•

### Implementation Guidelines for Executors

#### Frontend Implementation
- **MANDATORY: Search Before Implementing** - åœ¨å®ç°ä»»ä½•å‰ç«¯ä»£ç ä¹‹å‰ï¼Œå¿…é¡»å…ˆæœç´¢ä»£ç åº“ä¸­å·²æœ‰çš„ç±»ä¼¼å®ç°
  - ä½¿ç”¨ `grep_search` æˆ– `semantic_search` æŸ¥æ‰¾ç›¸å…³çš„ API è°ƒç”¨ã€æœåŠ¡æ–¹æ³•å’Œå·¥å…·å‡½æ•°
  - ç ”ç©¶ç°æœ‰ä»£ç çš„å‘½åæ¨¡å¼ã€å‚æ•°ç»“æ„å’Œè¿”å›å€¼å¤„ç†æ–¹å¼
  - ç¡®ä¿æ–°ä»£ç éµå¾ªä¸ç°æœ‰ä»£ç ç›¸åŒçš„çº¦å®šå’Œé£æ ¼
  - ç¤ºä¾‹æœç´¢å…³é”®è¯ï¼šç°æœ‰çš„ç±»ä¼¼åŠŸèƒ½åç§°ã€API ç«¯ç‚¹åç§°ã€ç›¸å…³ç»„ä»¶æ–¹æ³•
  - **ç»å¯¹ä¸è¦**çŒœæµ‹å‡½æ•°åç§°æˆ–æ¨¡å¼ - å§‹ç»ˆå…ˆå¯¹ç…§ç°æœ‰ä»£ç è¿›è¡ŒéªŒè¯

#### Backend Implementation
- **MANDATORY: Compile and Iterate** - å®Œæˆåç«¯ä»£ç ä¿®æ”¹åï¼Œå¿…é¡»è¿­ä»£ç¼–è¯‘å¹¶ä¿®å¤æ‰€æœ‰é”™è¯¯
  - æ­¥éª¤ 1: å®Œæˆä»£ç ä¿®æ”¹åï¼Œç«‹å³è¿è¡Œç¼–è¯‘è¿›è¡ŒéªŒè¯
  - æ­¥éª¤ 2: ä½¿ç”¨ `get_errors` å·¥å…·æ£€æŸ¥ç¼–è¯‘é”™è¯¯
  - æ­¥éª¤ 3: æ ¹æ®é”™è¯¯æ¶ˆæ¯ä¿®å¤é”™è¯¯ï¼ˆç±»å‹ä¸åŒ¹é…ã€ç¼ºå¤±å¼•ç”¨ã€å‘½åç©ºé—´é”™è¯¯ç­‰ï¼‰
  - æ­¥éª¤ 4: é‡å¤æ­¥éª¤ 1-3 ç›´åˆ°ç¼–è¯‘æˆåŠŸæ— é”™è¯¯
  - æ­¥éª¤ 5: ç¡®ä¿æ‰€æœ‰è­¦å‘Šéƒ½å·²ä¿®å¤æˆ–æœ‰æ–‡æ¡£è¯´æ˜ç†ç”±
  - ç¼–è¯‘å‘½ä»¤: `dotnet build [project_path]`
  - **ç»å¯¹ä¸è¦**åœ¨ç¼–è¯‘æˆåŠŸä¹‹å‰è®¤ä¸ºå®ç°å·²å®Œæˆ

## âœ¨ Success Criteria

### åŠŸèƒ½å®Œæ•´æ€§
- [x] æ”¯æŒæ‰€æœ‰æ ‡å‡† Modbus åŠŸèƒ½ç ï¼ˆ0x01-0x06, 0x0F, 0x10ï¼‰
- [x] å®Œæ•´çš„ CRC-16/MODBUS æ ¡éªŒå®ç°
- [x] ä¸²å£ä¼ è¾“å±‚åŸºäº Pipelines å®ç°
- [x] ä¸ TCP å®¢æˆ·ç«¯å…±äº«ç›¸åŒçš„ `IModbusClient` æ¥å£
- [x] æ”¯æŒæ‰€æœ‰æ‰©å±•æ•°æ®ç±»å‹ï¼ˆfloat, double, int32, uint32, byte[]ï¼‰
- [x] æ”¯æŒå­—èŠ‚åºé…ç½®å’Œ 1 åŸºåœ°å€æ¨¡å¼

### æ€§èƒ½æ ‡å‡†
- [x] CRC è®¡ç®—æ€§èƒ½ > 100 MB/s
- [x] è¯»å–è·¯å¾„ä¿æŒé›¶æ‹·è´æˆ–æœ€å°åˆ†é…
- [x] ä½¿ç”¨ `Span<T>` å’Œ `Memory<T>` è¿›è¡Œæ‰€æœ‰åè®®æ“ä½œ
- [x] ä¸ TCP å®ç°çš„æ€§èƒ½ç‰¹æ€§ç›¸å½“

### ä»£ç è´¨é‡
- [x] éµå¾ªç°æœ‰é¡¹ç›®çš„ä»£ç é£æ ¼å’Œå‘½åçº¦å®š
- [x] æ‰€æœ‰å…¬å…± API æœ‰å®Œæ•´çš„ XML æ–‡æ¡£æ³¨é‡Š
- [x] å…³é”®é€»è¾‘æœ‰æ¸…æ™°çš„ä»£ç æ³¨é‡Š
- [x] æ— ç¼–è¯‘è­¦å‘Š
- [x] é€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

### æ–‡æ¡£å®Œæ•´æ€§
- [x] README.md åŒ…å« RTU ä½¿ç”¨ç¤ºä¾‹
- [x] ä¸²å£é…ç½®å‚æ•°æœ‰æ¸…æ™°è¯´æ˜
- [x] æä¾›å®Œæ•´çš„ç¤ºä¾‹ä»£ç 
- [x] æ›´æ–°æ¶æ„æ–‡æ¡£

### å…¼å®¹æ€§
- [x] ä¸ç°æœ‰ TCP å®ç°å…±äº«æ ¸å¿ƒç»„ä»¶ï¼ˆPDU Builder/Parser, DataConverterï¼‰
- [x] ä¸ç ´åç°æœ‰ API çš„å‘åå…¼å®¹æ€§
- [x] æ”¯æŒ .NET 8.0 å’Œæ›´é«˜ç‰ˆæœ¬
- [x] éµå¾ª Modbus RTU å®˜æ–¹è§„èŒƒ

### æµ‹è¯•è¦†ç›–ç‡
- [x] CRC ç®—æ³•å•å…ƒæµ‹è¯•è¦†ç›–ç‡ 100%
- [x] ADU æ„å»º/è§£æå•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 90%
- [x] ä¸ Modbus RTU æ¨¡æ‹Ÿå™¨çš„é›†æˆæµ‹è¯•é€šè¿‡
- [x] æ‰€æœ‰åŠŸèƒ½ç å’Œæ•°æ®ç±»å‹çš„ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡
