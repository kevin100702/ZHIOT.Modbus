# 实施计划: 高性能 Modbus 功能扩展

## ?? 需求概述

此计划旨在对现有的 Modbus TCP 库进行功能扩展和性能优化。核心目标是提供一个功能更全面、性能更卓越、API 更现代化的 Modbus 客户端。具体需求如下：

1.  **支持多种数据类型**: 扩展 API，使其原生支持 `float`, `double`, `int32`, `uint32` 等常见工业数据类型的读写。
2.  **灵活的字节序处理**: 提供简单易用的配置项，以处理不同设备所需的大端 (Big Endian)、小端 (Little Endian) 及字交换 (Word Swap) 等字节序问题。
3.  **原始字节访问**: 提供 `byte[]` 数组的读写重载方法，允许高级用户绕过内置的数据转换逻辑，自行解析和处理原始报文数据。
4.  **兼容 1 基地址**: 添加一个客户端级别的配置开关，使其能兼容从 1 开始的地址（而不是协议标准的 0 基地址），以方便与特定设备对接。
5.  **高性能读取**: 优化数据读取路径，消除不必要的内存分配和数据复制。利用 `Span<T>` 和现代 .NET 技术，实现从网络报文到目标数据类型的近乎零分配的转换，显著提升高频轮询和大数据量读取场景下的性能。

## ?? 待办清单

- [ ] 定义 `ByteOrder` 枚举以支持多种字节序模式。
- [ ] 创建高性能的 `ModbusDataConverter` 工具类，支持 `Span<T>` 操作。
- [ ] 重构 `ModbusPduParser`，实现从 PDU 到目标 `Span<T>` 的直接解析。
- [ ] 在客户端 (`IModbusClient`, `ModbusTcpClient`) 中添加 `IsOneBasedAddressing` 配置属性。
- [ ] 在客户端接口和实现中添加所有新数据类型 (`float`, `double`, `int32`, `uint32`) 和 `byte[]` 的高性能读写方法。
- [ ] 编写全面的单元测试，覆盖数据转换、字节序处理和新 API 的功能。
- [ ] 完成最终的代码审查、API 文档更新和集成测试。

## ?? 设计与分析

### 核心设计思想：性能优先

当前实现中，数据读取路径为 `网络字节流 -> PDU(byte[]) -> ushort[]`。如果继续采用此路径再转换成`目标类型[]`存在至少一次不必要的中间数组（`ushort[]`）分配，在高频和小数据量场景下，这会给垃圾回收（GC）带来压力，影响整体性能。

**优化后的设计**将彻底改变这一流程。新的读取路径为 `网络字节流 -> PDU(ReadOnlySpan<byte>) -> 目标类型[]`。通过在 `ModbusPduParser` 和 `ModbusDataConverter` 中全面采用 `Span<T>` 和 `ReadOnlySpan<T>`，我们可以直接在原始的 PDU 内存切片上进行操作，从而避免任何中间数据拷贝和内存分配。

- **对于读取操作**: 我们将 PDU 的数据部分（`ReadOnlySpan<byte>`）直接传递给转换器。转换器根据目标类型和字节序配置，高效地将字节流转换为目标类型数组。如果字节序与平台默认序一致，可利用 `MemoryMarshal.Cast` 实现零拷贝转换；否则，使用 `BinaryPrimitives` 进行高效的逐元素转换。
- **对于写入操作**: 数据转换（例如 `float[] -> ushort[]`）是不可避免的，因为 Modbus 协议要求以 16 位寄存器的形式发送数据。但我们依然可以通过 `Span<T>` 来优化这个过程，减少中间环节的内存占用。

### 关键组件职责

1.  **`ModbusPduParser` (解析器)**
    - **职责**: 仅负责从 Modbus 响应 PDU 中提取原始的寄存器数据（payload）。
    - **接口变更**: 废弃返回 `ushort[]` 的方法，提供一个新方法，如 `ReadOnlySpan<byte> ParseRegistersResponsePayload(ReadOnlySpan<byte> pdu)`，它仅返回包含寄存器数据的内存切片，不进行任何解析和分配。

2.  **`ModbusDataConverter` (转换器)**
    - **职责**: 作为数据转换的核心。负责 `ReadOnlySpan<byte>` 与具体类型数组（`float[]`, `int[]` 等）之间的双向转换，并处理所有字节序逻辑。
    - **核心方法**:
        - `T[] ToArray<T>(ReadOnlySpan<byte> source, ByteOrder byteOrder)`: 用于读取操作，将原始字节转换为目标类型数组。
        - `ushort[] ToRegisters<T>(T[] values, ByteOrder byteOrder)`: 用于写入操作，将目标类型数组转换为 Modbus 寄存器数组。
        - `T ToValue<T>(ReadOnlySpan<byte> source, ByteOrder byteOrder)`: 用于读取单个值的重载。

3.  **`ModbusTcpClient` (客户端)**
    - **职责**: 协调者。负责网络通信、地址调整（1基/0基），并调用 `ModbusPduParser` 和 `ModbusDataConverter` 来完成一次完整的读写操作。
    - **实现流程 (以 `ReadFloatsAsync` 为例)**:
        1.  根据 `IsOneBasedAddressing` 调整用户传入的 `startAddress`。
        2.  发送 Modbus 请求，接收响应 PDU (`byte[]`)。
        3.  调用 `ModbusPduParser` 从 PDU 中提取出寄存器数据的 `ReadOnlySpan<byte>`。
        4.  调用 `ModbusDataConverter.ToArray<float>(payload, byteOrder)`，传入数据切片和字节序配置，获取最终的 `float[]` 结果。
        5.  返回结果。

## ?? 实施计划

### 第 1 步: 定义核心类型和重构解析器

- **文件**: `src/ZHIOT.Modbus/Core/ByteOrder.cs`, `src/ZHIOT.Modbus/Core/ModbusPduParser.cs`
- **变更**:
    1.  创建 `ByteOrder.cs` 并定义 `enum ByteOrder`，至少包含 `BigEndian`(ABCD), `LittleEndian`(DCBA), `BigEndianSwap`(BADC), `LittleEndianSwap`(DCBA)。
    2.  在 `ModbusPduParser.cs` 中，修改 `ParseReadHoldingRegistersResponse` 和 `ParseReadInputRegistersResponse` 方法。使其不再创建和返回 `ushort[]`，而是返回一个包含原始寄存器数据的 `ReadOnlySpan<byte>`。这将成为所有后续转换的输入。

### 第 2 步: 创建高性能数据转换器

- **文件**: `src/ZHIOT.Modbus/Utils/ModbusDataConverter.cs`
- **变更**:
    1.  创建静态类 `ModbusDataConverter`。
    2.  实现 `public static T[] ToArray<T>(ReadOnlySpan<byte> source, ByteOrder byteOrder) where T : struct` 方法。此方法是读取性能的关键。
    3.  实现 `public static ushort[] ToRegisters<T>(T[] values, ByteOrder byteOrder) where T : struct` 方法，用于写入操作。

### 第 3 步: 扩展客户端功能

- **文件**: `src/ZHIOT.Modbus/Abstractions/IModbusClient.cs`, `src/ZHIOT.Modbus/Client/ModbusTcpClient.cs`
- **变更**:
    1.  在 `IModbusClient` 接口中添加 `bool IsOneBasedAddressing { get; set; }` 属性。
    2.  在 `IModbusClient` 接口中为所有新数据类型（`float`, `double`, `int32`, `uint32`, `byte[]`）添加 `...Async` 读写方法签名。
    3.  在 `ModbusTcpClient` 中实现这些新方法。读取方法需严格遵循“设计与分析”中描述的高性能路径。写入方法则调用 `ModbusDataConverter` 准备待发送的 `ushort[]` 数据。

### 第 4 步: 编写和迁移测试

- **文件**: `tests/ZHIOT.Modbus.Tests/` 目录
- **变更**:
    1.  创建 `ModbusDataConverterTests.cs`，对所有数据类型和字节序组合进行详尽的单元测试。
    2.  更新 `ModbusPduParserTests.cs` 以适应其返回 `ReadOnlySpan<byte>` 的新行为。
    3.  在 `ModbusTcpClient` 的测试中，为所有新的 API 端点添加集成测试，模拟 `ITransport` 以验证端到端的逻辑正确性。

## ?? 测试策略

1.  **单元测试**: 确保 `ModbusDataConverter` 在所有边界条件下（如空数组、奇数长度字节数组等）和所有 `ByteOrder` 模式下都能正确转换数据。
2.  **集成测试**: 模拟 Modbus 服务器，对 `ModbusTcpClient` 的每个公共 API 进行测试，覆盖读、写、不同数据类型、1基地址等所有功能点。
3.  **端到端测试**: 如果有可用的物理或虚拟 Modbus 设备，进行实际的端到端通信测试，以确保协议兼容性。
4.  **性能基准测试**: 使用 `BenchmarkDotNet` 测量关键读取方法的执行时间和内存分配，并将其作为发布标准之一。

## ?? 成功标准

- **功能完整**: 所有在“需求概述”中列出的功能都已实现并通过测试。
- **性能达标**: 新的读取 API 在内存分配上显著优于旧实现，基准测试结果证明了这一点。
- **代码质量**: 代码风格统一，遵循现有项目规范，关键逻辑有清晰的注释。
- **文档齐全**: 所有公共 API 都有完整的 XML 注释，清晰说明其功能、参数和返回值。`README.md` 或相关文档中应有新功能的用法示例。
- **向后兼容性**: 现有的公共 API 行为保持不变，确保不会破坏旧用户的代码（除非明确标记为 `[Obsolete]`）。
