# Feature Implementation Plan: CRC16-å¥‡å¶æ ¡éªŒåˆ‡æ¢

## âœ… Todo Checklist
- [ ] åœ¨ `ModbusRtuTypes.cs` ä¸­æ·»åŠ  `Crc16Variant` æšä¸¾ç±»å‹
- [ ] ä¿®æ”¹ `ModbusCrc16.cs` æ·»åŠ æ”¯æŒå¥‡å¶å˜ä½“çš„è®¡ç®—å’ŒéªŒè¯æ–¹æ³•
- [ ] åœ¨ `SerialPortSettings` ç±»ä¸­æ·»åŠ  `Crc16Variant` é…ç½®å±æ€§
- [ ] ä¿®æ”¹ `IModbusClient` æ¥å£æ·»åŠ  `Crc16Variant` å±æ€§
- [ ] æ›´æ–° `ModbusRtuClient` å®ç°ä»¥æ”¯æŒå¯é…ç½®çš„ CRC å˜ä½“
- [ ] ä¿®æ”¹ `ModbusRtuAduBuilder` å’Œ `ModbusRtuAduParser` ä»¥æ”¯æŒ CRC å˜ä½“å‚æ•°
- [ ] æ›´æ–° `ModbusClientFactory` ä»¥æ”¯æŒ CRC å˜ä½“é…ç½®
- [ ] æ·»åŠ å•å…ƒæµ‹è¯•éªŒè¯å¥‡å¶ä¸¤ç§ CRC å˜ä½“
- [ ] æ›´æ–°ç¤ºä¾‹ä»£ç å±•ç¤ºå¦‚ä½•åˆ‡æ¢ CRC å˜ä½“
- [ ] Final Review and Testing

## ğŸ” Analysis & Investigation

### Codebase Structure
å½“å‰ä»£ç åº“ç»“æ„æ¸…æ™°ï¼Œä¸»è¦ç›¸å…³æ–‡ä»¶åŒ…æ‹¬ï¼š
- `src/ZHIOT.Modbus/Core/ModbusCrc16.cs` - CRC-16 è®¡ç®—å’ŒéªŒè¯çš„æ ¸å¿ƒå®ç°
- `src/ZHIOT.Modbus/Core/ModbusRtuTypes.cs` - RTU ç›¸å…³ç±»å‹å®šä¹‰
- `src/ZHIOT.Modbus/Core/ModbusRtuAduBuilder.cs` - RTU ADU æ„å»ºå™¨
- `src/ZHIOT.Modbus/Core/ModbusRtuAduParser.cs` - RTU ADU è§£æå™¨
- `src/ZHIOT.Modbus/Client/ModbusRtuClient.cs` - RTU å®¢æˆ·ç«¯å®ç°
- `src/ZHIOT.Modbus/Abstractions/IModbusClient.cs` - å®¢æˆ·ç«¯æ¥å£å®šä¹‰
- `src/ZHIOT.Modbus/ModbusClientFactory.cs` - å®¢æˆ·ç«¯å·¥å‚ç±»
- `tests/ZHIOT.Modbus.Tests/ModbusCrc16Tests.cs` - CRC æµ‹è¯•

### Current Architecture
å½“å‰çš„ CRC-16 å®ç°ï¼š
- ä½¿ç”¨æŸ¥è¡¨æ³•å®ç°é«˜æ€§èƒ½è®¡ç®—
- å¤šé¡¹å¼ï¼š0xA001ï¼ˆåå‘ï¼‰
- åˆå§‹å€¼ï¼š0xFFFF
- **æœ€ç»ˆå¼‚æˆ–ï¼š0x0000**ï¼ˆå¶æ ¡éªŒï¼ŒModbus æ ‡å‡†ï¼‰
- `Calculate` æ–¹æ³•è®¡ç®— CRC å€¼
- `Verify` æ–¹æ³•éªŒè¯å®Œæ•´å¸§çš„ CRC

ç°å®ä¸­å­˜åœ¨çš„é—®é¢˜ï¼š
- Modbus RTU å®˜æ–¹è§„èŒƒä½¿ç”¨ XorOut = 0x0000ï¼ˆå¶æ ¡éªŒï¼‰
- å¤§é‡è®¾å¤‡ä½¿ç”¨ XorOut = 0xFFFFï¼ˆå¥‡æ ¡éªŒï¼‰
- å½“è®¾å¤‡ä½¿ç”¨ä¸åŒå˜ä½“æ—¶ï¼Œä¼šå¯¼è‡´ CRC æ ¡éªŒå¤±è´¥
- ç›®å‰ä»£ç ç¡¬ç¼–ç ä¸ºå¶æ ¡éªŒï¼Œæ— æ³•åˆ‡æ¢

### Dependencies & Integration Points
éœ€è¦ä¿®æ”¹çš„é›†æˆç‚¹ï¼š
1. **ModbusCrc16** - æ ¸å¿ƒè®¡ç®—é€»è¾‘éœ€è¦æ”¯æŒä¸¤ç§å˜ä½“
2. **ModbusRtuAduBuilder** - æ„å»º ADU æ—¶éœ€è¦ä½¿ç”¨æŒ‡å®šçš„ CRC å˜ä½“
3. **ModbusRtuAduParser** - è§£æéªŒè¯æ—¶éœ€è¦ä½¿ç”¨æŒ‡å®šçš„ CRC å˜ä½“
4. **ModbusRtuClient** - å®¢æˆ·ç«¯éœ€è¦å­˜å‚¨å¹¶ä¼ é€’ CRC å˜ä½“é…ç½®
5. **SerialPortSettings** - é…ç½®ç±»éœ€è¦åŒ…å« CRC å˜ä½“é€‰é¡¹
6. **IModbusClient** - æ¥å£éœ€è¦æš´éœ² CRC å˜ä½“å±æ€§ï¼ˆç±»ä¼¼ ByteOrderï¼‰

### Considerations & Challenges

#### æŠ€æœ¯æŒ‘æˆ˜
1. **å‘åå…¼å®¹æ€§** - å¿…é¡»ä¿æŒé»˜è®¤è¡Œä¸ºä¸ºå¶æ ¡éªŒï¼ˆModbus æ ‡å‡†ï¼‰ï¼Œä¸èƒ½ç ´åç°æœ‰ä»£ç 
2. **æ€§èƒ½å½±å“** - CRC è®¡ç®—æ˜¯é«˜é¢‘æ“ä½œï¼Œæ–°å¢å‚æ•°ä¸èƒ½æ˜¾è‘—å½±å“æ€§èƒ½
3. **API ä¸€è‡´æ€§** - éœ€è¦ä¸ç°æœ‰çš„ `ByteOrder`ã€`IsOneBasedAddressing` ç­‰é…ç½®å±æ€§ä¿æŒä¸€è‡´çš„è®¾è®¡é£æ ¼
4. **ä¼ é€’è·¯å¾„** - CRC å˜ä½“éœ€è¦ä»å®¢æˆ·ç«¯é…ç½®ä¸€ç›´ä¼ é€’åˆ° `ModbusCrc16` çš„è®¡ç®—æ–¹æ³•

#### è®¾è®¡è€ƒè™‘
1. ä½¿ç”¨æšä¸¾ç±»å‹ `Crc16Variant` æ¸…æ™°è¡¨ç¤ºå¥‡å¶ä¸¤ç§å˜ä½“
2. åœ¨ `IModbusClient` æ¥å£æ·»åŠ å±æ€§ï¼Œå…è®¸è¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢ï¼ˆç±»ä¼¼ `ByteOrder`ï¼‰
3. ä¿®æ”¹ `ModbusCrc16` çš„é™æ€æ–¹æ³•ï¼Œå¢åŠ å¯é€‰çš„å˜ä½“å‚æ•°ï¼Œé»˜è®¤ä¸ºå¶æ ¡éªŒ
4. æ›´æ–° ADU æ„å»ºå™¨å’Œè§£æå™¨ï¼Œä»å®¢æˆ·ç«¯è·å– CRC å˜ä½“é…ç½®

## ğŸ“‹ Implementation Plan

### Prerequisites
- äº†è§£ CRC-16/MODBUS ç®—æ³•åŸç†
- ç†è§£å¥‡å¶å˜ä½“çš„åŒºåˆ«ï¼ˆä»…åœ¨æœ€ç»ˆå¼‚æˆ–å€¼ä¸åŒï¼š0x0000 vs 0xFFFFï¼‰
- ç¡®ä¿æ‰€æœ‰ç°æœ‰å•å…ƒæµ‹è¯•é€šè¿‡

### Step-by-Step Implementation

#### æ­¥éª¤ 1: å®šä¹‰ CRC-16 å˜ä½“æšä¸¾
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Core/ModbusRtuTypes.cs`
- **å˜æ›´å†…å®¹**: 
  - æ·»åŠ  `Crc16Variant` æšä¸¾ï¼ŒåŒ…å« `Even`ï¼ˆå¶ï¼Œ0x0000ï¼‰å’Œ `Odd`ï¼ˆå¥‡ï¼Œ0xFFFFï¼‰ä¸¤ä¸ªå€¼
  - æ·»åŠ  XML æ–‡æ¡£æ³¨é‡Šï¼Œè¯´æ˜ä¸¤ç§å˜ä½“çš„åŒºåˆ«å’Œä½¿ç”¨åœºæ™¯
- **ç¤ºä¾‹ä»£ç **:
```csharp
/// <summary>
/// CRC-16 æ ¡éªŒå˜ä½“
/// Modbus RTU æœ‰ä¸¤ç§ CRC-16 å®é™…å˜ä½“ï¼ŒåŒºåˆ«åœ¨äºæœ€ç»ˆå¼‚æˆ–å€¼ï¼ˆXorOutï¼‰
/// </summary>
public enum Crc16Variant
{
    /// <summary>
    /// å¶æ ¡éªŒï¼ˆEvenï¼‰- XorOut = 0x0000
    /// Modbus RTU å®˜æ–¹æ ‡å‡†è§„èŒƒä½¿ç”¨æ­¤å˜ä½“
    /// </summary>
    Even = 0,

    /// <summary>
    /// å¥‡æ ¡éªŒï¼ˆOddï¼‰- XorOut = 0xFFFF
    /// å¤§é‡ç°å®è®¾å¤‡ä½¿ç”¨æ­¤å˜ä½“ï¼Œå½“æ ‡å‡†å¶æ ¡éªŒå¤±è´¥æ—¶å¯å°è¯•åˆ‡æ¢
    /// </summary>
    Odd = 1
}
```

#### æ­¥éª¤ 2: æ›´æ–° SerialPortSettings é…ç½®ç±»
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Core/ModbusRtuTypes.cs`
- **å˜æ›´å†…å®¹**:
  - åœ¨ `SerialPortSettings` ç±»ä¸­æ·»åŠ  `Crc16Variant` å±æ€§
  - é»˜è®¤å€¼è®¾ç½®ä¸º `Crc16Variant.Even`ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
- **ç¤ºä¾‹ä»£ç **:
```csharp
/// <summary>
/// CRC-16 æ ¡éªŒå˜ä½“ï¼Œé»˜è®¤ä¸ºå¶æ ¡éªŒï¼ˆModbus æ ‡å‡†ï¼‰
/// å½“é‡åˆ° CRC æ ¡éªŒå¤±è´¥æ—¶ï¼Œå¯å°è¯•åˆ‡æ¢åˆ°å¥‡æ ¡éªŒ
/// </summary>
public Crc16Variant Crc16Variant { get; set; } = Crc16Variant.Even;
```

#### æ­¥éª¤ 3: ä¿®æ”¹ ModbusCrc16 æ ¸å¿ƒç®—æ³•
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Core/ModbusCrc16.cs`
- **å˜æ›´å†…å®¹**:
  - ä¿ç•™ç°æœ‰çš„ `Calculate(ReadOnlySpan<byte> data)` æ–¹æ³•ï¼ˆé»˜è®¤å¶æ ¡éªŒï¼‰ï¼Œä¿æŒå‘åå…¼å®¹
  - æ·»åŠ é‡è½½æ–¹æ³• `Calculate(ReadOnlySpan<byte> data, Crc16Variant variant)`
  - ä¿ç•™ç°æœ‰çš„ `Verify(ReadOnlySpan<byte> frame)` æ–¹æ³•ï¼ˆé»˜è®¤å¶æ ¡éªŒï¼‰
  - æ·»åŠ é‡è½½æ–¹æ³• `Verify(ReadOnlySpan<byte> frame, Crc16Variant variant)`
  - åœ¨è®¡ç®—æ–¹æ³•çš„æœ€åæ ¹æ®å˜ä½“ç±»å‹å†³å®šæ˜¯å¦å¯¹ç»“æœå–å
- **å…³é”®é€»è¾‘**:
```csharp
// åœ¨ Calculate æ–¹æ³•çš„æœ€å
public static ushort Calculate(ReadOnlySpan<byte> data, Crc16Variant variant = Crc16Variant.Even)
{
    ushort crc = 0xFFFF;

    foreach (byte b in data)
    {
        byte tableIndex = (byte)(crc ^ b);
        crc = (ushort)((crc >> 8) ^ CrcTable[tableIndex]);
    }

    // æ ¹æ®å˜ä½“ç±»å‹å†³å®šæ˜¯å¦å–å
    if (variant == Crc16Variant.Odd)
    {
        crc ^= 0xFFFF;
    }

    return crc;
}
```

#### æ­¥éª¤ 4: æ›´æ–° IModbusClient æ¥å£
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Abstractions/IModbusClient.cs`
- **å˜æ›´å†…å®¹**:
  - **ä¸æ·»åŠ ** `Crc16Variant` å±æ€§åˆ°æ¥å£ï¼ˆCRC æ ¡éªŒæ˜¯ RTU ç‰¹æœ‰çš„ï¼ŒTCP ä¸ä½¿ç”¨ï¼‰
  - ä¿æŒæ¥å£çš„é€šç”¨æ€§å’Œç®€æ´æ€§
- **è®¾è®¡è¯´æ˜**: 
  - CRC-16 æ ¡éªŒæ˜¯ Modbus RTU åè®®ç‰¹æœ‰çš„åŠŸèƒ½
  - Modbus TCP ä½¿ç”¨ TCP/IP å±‚çš„æ ¡éªŒï¼Œä¸éœ€è¦ CRC-16
  - å°†æ­¤å±æ€§æ·»åŠ åˆ°æ¥å£ä¼šæ±¡æŸ“æ¥å£è®¾è®¡
  - åº”è¯¥åªåœ¨ `ModbusRtuClient` å…·ä½“å®ç°ä¸­æä¾›æ­¤å±æ€§

#### æ­¥éª¤ 5: æ›´æ–° ModbusTcpClient å®ç°
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Client/ModbusTcpClient.cs`
- **å˜æ›´å†…å®¹**:
  - ä¸æ·»åŠ  `Crc16Variant` å±æ€§ï¼ˆTCP ä¸éœ€è¦ CRC æ ¡éªŒï¼‰
  - ä¿æŒå®ç°çš„ç®€æ´æ€§å’Œåè®®ç‰¹æ€§çš„å‡†ç¡®æ€§

#### æ­¥éª¤ 6: æ›´æ–° ModbusRtuClient å®ç°
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Client/ModbusRtuClient.cs`
- **å˜æ›´å†…å®¹**:
  - æ·»åŠ  `Crc16Variant` å±æ€§ï¼ˆRTU ç‰¹æœ‰çš„ CRC åŠŸèƒ½ï¼‰
  - å±æ€§é»˜è®¤å€¼ä¸º `Crc16Variant.Even`ï¼ˆModbus RTU æ ‡å‡†ï¼‰
  - åœ¨ `SendRequestAsync` æ–¹æ³•ä¸­ï¼Œå°† CRC å˜ä½“ä¼ é€’ç»™ `ModbusRtuAduBuilder.BuildAdu`
  - åœ¨ `TryParseResponse` æ–¹æ³•ä¸­ï¼Œå°† CRC å˜ä½“ä¼ é€’ç»™ `ModbusRtuAduParser.VerifyCrc`
- **å…³é”®ç‰¹ç‚¹**:
  - æ­¤å±æ€§ä»…åœ¨ RTU å®¢æˆ·ç«¯ä¸­å­˜åœ¨ï¼Œä¸æ±¡æŸ“æ¥å£
  - è®¾è®¡æ›´æ¸…æ™°ï¼Œå‡†ç¡®åæ˜  RTU åè®®çš„ç‰¹æ€§
  - æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢ CRC å˜ä½“
- **ç¤ºä¾‹ä»£ç **:
```csharp
/// <summary>
/// è·å–æˆ–è®¾ç½® CRC-16 æ ¡éªŒå˜ä½“ï¼Œé»˜è®¤ä¸ºå¶æ ¡éªŒï¼ˆModbus RTU æ ‡å‡†ï¼‰
/// æ­¤å±æ€§ä»…å¯¹ Modbus RTU åè®®æœ‰æ•ˆï¼ŒModbus TCP ä¸ä½¿ç”¨ CRC æ ¡éªŒ
/// å½“é‡åˆ° CRC æ ¡éªŒå¤±è´¥æ—¶ï¼Œå¯å°è¯•åˆ‡æ¢åˆ°å¥‡æ ¡éªŒï¼ˆOddï¼‰
/// </summary>
public Crc16Variant Crc16Variant { get; set; } = Crc16Variant.Even;
```

#### æ­¥éª¤ 7: æ›´æ–° ModbusRtuAduBuilder
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Core/ModbusRtuAduBuilder.cs`
- **å˜æ›´å†…å®¹**:
  - ä¿ç•™ç°æœ‰çš„ `BuildAdu` æ–¹æ³•ï¼ˆé»˜è®¤å¶æ ¡éªŒï¼‰
  - æ·»åŠ é‡è½½æ–¹æ³•æ¥å— `Crc16Variant` å‚æ•°
  - åœ¨è®¡ç®— CRC æ—¶ä¼ é€’å˜ä½“å‚æ•°
- **ç¤ºä¾‹ä»£ç **:
```csharp
public static int BuildAdu(Span<byte> buffer, byte slaveId, ReadOnlySpan<byte> pdu, Crc16Variant variant = Crc16Variant.Even)
{
    if (buffer.Length < 1 + pdu.Length + 2)
        throw new ArgumentException("Buffer is too small", nameof(buffer));

    buffer[0] = slaveId;
    pdu.CopyTo(buffer.Slice(1));
    int frameLength = 1 + pdu.Length;

    var crc = ModbusCrc16.Calculate(buffer.Slice(0, frameLength), variant);
    BinaryPrimitives.WriteUInt16LittleEndian(buffer.Slice(frameLength), crc);

    return frameLength + 2;
}
```

#### æ­¥éª¤ 8: æ›´æ–° ModbusRtuAduParser
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Core/ModbusRtuAduParser.cs`
- **å˜æ›´å†…å®¹**:
  - ä¿ç•™ç°æœ‰æ–¹æ³•ï¼ˆé»˜è®¤å¶æ ¡éªŒï¼‰
  - ä¸º `ExtractPdu` å’Œ `VerifyCrc` æ–¹æ³•æ·»åŠ æ¥å— `Crc16Variant` å‚æ•°çš„é‡è½½
- **ç¤ºä¾‹ä»£ç **:
```csharp
public static ReadOnlySpan<byte> ExtractPdu(ReadOnlySpan<byte> adu, Crc16Variant variant = Crc16Variant.Even)
{
    if (adu.Length < RtuAdu.MinSize)
        throw new InvalidOperationException($"ADU too short: {adu.Length} bytes (minimum {RtuAdu.MinSize})");

    if (!ModbusCrc16.Verify(adu, variant))
        throw new InvalidOperationException("CRC verification failed");

    return adu.Slice(1, adu.Length - 3);
}

public static bool VerifyCrc(ReadOnlySpan<byte> adu, Crc16Variant variant = Crc16Variant.Even)
{
    if (adu.Length < RtuAdu.MinSize)
        return false;

    return ModbusCrc16.Verify(adu, variant);
}
```

#### æ­¥éª¤ 9: æ›´æ–° ModbusClientFactory
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/ModbusClientFactory.cs`
- **å˜æ›´å†…å®¹**:
  - åœ¨ä½¿ç”¨ `SerialPortSettings` åˆ›å»ºå®¢æˆ·ç«¯æ—¶ï¼Œç¡®ä¿ `Crc16Variant` è¢«ä¼ é€’
  - ä¸ºä¾¿æ·é‡è½½æ–¹æ³•æ·»åŠ å¯é€‰çš„ `crc16Variant` å‚æ•°
- **ç¤ºä¾‹ä»£ç **:
```csharp
public static IModbusClient CreateRtuClient(
    string portName,
    int baudRate = 9600,
    Parity parity = Parity.None,
    int dataBits = 8,
    StopBits stopBits = StopBits.One,
    Crc16Variant crc16Variant = Crc16Variant.Even)
{
    var settings = new SerialPortSettings
    {
        PortName = portName,
        BaudRate = baudRate,
        Parity = parity,
        DataBits = dataBits,
        StopBits = stopBits,
        Crc16Variant = crc16Variant
    };
    return CreateRtuClient(settings);
}
```

#### æ­¥éª¤ 10: ç¡®ä¿å·¥å‚æ–¹æ³•æ­£ç¡®ä¼ é€’é…ç½®
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/ModbusClientFactory.cs`
- **å˜æ›´å†…å®¹**:
  - åœ¨ `CreateRtuClient(SerialPortSettings settings)` ä¸­ï¼Œä»è®¾ç½®å¯¹è±¡è¯»å– `Crc16Variant` å¹¶è®¾ç½®åˆ°å®¢æˆ·ç«¯
  - ç¡®ä¿é…ç½®èƒ½æ­£ç¡®ä¼ é€’åˆ° `ModbusRtuClient` å®ä¾‹
- **ç¤ºä¾‹ä»£ç **:
```csharp
public static IModbusClient CreateRtuClient(SerialPortSettings settings)
{
    var transport = new SerialPortTransport(settings);
    var client = new ModbusRtuClient(transport);
    client.Crc16Variant = settings.Crc16Variant;  // åº”ç”¨é…ç½®
    return client;
}
```

#### æ­¥éª¤ 11: æ›´æ–°æ‰€æœ‰ ADU æ“ä½œè°ƒç”¨
- **æ–‡ä»¶**: `src/ZHIOT.Modbus/Client/ModbusRtuClient.cs`
- **å˜æ›´å†…å®¹**:
  - åœ¨ `SendRequestAsync` æ–¹æ³•ä¸­ï¼Œè°ƒç”¨ `ModbusRtuAduBuilder.BuildAdu` æ—¶ä¼ é€’ `Crc16Variant` å±æ€§
  - åœ¨ `TryParseResponse` æ–¹æ³•ä¸­ï¼Œè°ƒç”¨ `ModbusRtuAduParser.VerifyCrc` æ—¶ä¼ é€’ `Crc16Variant` å±æ€§
- **ä¿®æ”¹ç‚¹**:
```csharp
// åœ¨ SendRequestAsync ä¸­
var adu = new byte[1 + pdu.Length + 2];
ModbusRtuAduBuilder.BuildAdu(adu, slaveId, pdu, Crc16Variant);

// åœ¨ TryParseResponse ä¸­
if (!ModbusRtuAduParser.VerifyCrc(frame, Crc16Variant))
{
    buffer = buffer.Slice(1);
    return false;
}
```

#### æ­¥éª¤ 12: æ·»åŠ å•å…ƒæµ‹è¯• - CRC å˜ä½“è®¡ç®—
- **æ–‡ä»¶**: `tests/ZHIOT.Modbus.Tests/ModbusCrc16Tests.cs`
- **å˜æ›´å†…å®¹**:
  - æ·»åŠ æµ‹è¯•éªŒè¯å¶æ ¡éªŒï¼ˆEvenï¼‰CRC è®¡ç®—æ­£ç¡®æ€§
  - æ·»åŠ æµ‹è¯•éªŒè¯å¥‡æ ¡éªŒï¼ˆOddï¼‰CRC è®¡ç®—æ­£ç¡®æ€§
  - æ·»åŠ æµ‹è¯•éªŒè¯åŒä¸€æ•°æ®åœ¨ä¸¤ç§å˜ä½“ä¸‹çš„ CRC å€¼ä¸åŒ
  - æ·»åŠ æµ‹è¯•éªŒè¯ `Verify` æ–¹æ³•å¯¹ä¸¤ç§å˜ä½“çš„æ”¯æŒ
- **æµ‹è¯•ç”¨ä¾‹**:
```csharp
[TestMethod]
public void Calculate_EvenVariant_ReturnsCorrectCrc()
{
    // ä½¿ç”¨å·²çŸ¥çš„ Modbus æ ‡å‡†å¸§
    byte[] data = { 0x01, 0x03, 0x00, 0x00, 0x00, 0x0A };
    ushort expectedCrc = 0xCDC5; // å·²çŸ¥æ­£ç¡®å€¼

    ushort actualCrc = ModbusCrc16.Calculate(data, Crc16Variant.Even);

    Assert.AreEqual(expectedCrc, actualCrc);
}

[TestMethod]
public void Calculate_OddVariant_ReturnsInvertedCrc()
{
    byte[] data = { 0x01, 0x03, 0x00, 0x00, 0x00, 0x0A };
    ushort evenCrc = ModbusCrc16.Calculate(data, Crc16Variant.Even);
    ushort oddCrc = ModbusCrc16.Calculate(data, Crc16Variant.Odd);

    // å¥‡æ ¡éªŒ = å¶æ ¡éªŒå–å
    Assert.AreEqual((ushort)(evenCrc ^ 0xFFFF), oddCrc);
}

[TestMethod]
public void Verify_EvenVariant_ValidFrame_ReturnsTrue()
{
    // æ ‡å‡† Modbus å¶æ ¡éªŒå¸§
    byte[] frame = { 0x01, 0x03, 0x00, 0x00, 0x00, 0x0A, 0xC5, 0xCD };
    
    bool isValid = ModbusCrc16.Verify(frame, Crc16Variant.Even);
    
    Assert.IsTrue(isValid);
}

[TestMethod]
public void Verify_OddVariant_ValidFrame_ReturnsTrue()
{
    // æ„å»ºå¥‡æ ¡éªŒå¸§
    byte[] data = { 0x01, 0x03, 0x00, 0x00, 0x00, 0x0A };
    ushort oddCrc = ModbusCrc16.Calculate(data, Crc16Variant.Odd);
    
    byte[] frame = new byte[data.Length + 2];
    data.CopyTo(frame, 0);
    frame[data.Length] = (byte)(oddCrc & 0xFF);
    frame[data.Length + 1] = (byte)(oddCrc >> 8);
    
    bool isValid = ModbusCrc16.Verify(frame, Crc16Variant.Odd);
    
    Assert.IsTrue(isValid);
}

[TestMethod]
public void Verify_WrongVariant_ReturnsFalse()
{
    // å¶æ ¡éªŒå¸§ç”¨å¥‡æ ¡éªŒéªŒè¯åº”è¯¥å¤±è´¥
    byte[] frame = { 0x01, 0x03, 0x00, 0x00, 0x00, 0x0A, 0xC5, 0xCD };
    
    bool isValid = ModbusCrc16.Verify(frame, Crc16Variant.Odd);
    
    Assert.IsFalse(isValid);
}
```

#### æ­¥éª¤ 13: æ·»åŠ é›†æˆæµ‹è¯• - ADU æ„å»ºå’Œè§£æ
- **æ–‡ä»¶**: `tests/ZHIOT.Modbus.Tests/ModbusRtuAduBuilderTests.cs` å’Œ `ModbusRtuAduParserTests.cs`
- **å˜æ›´å†…å®¹**:
  - æµ‹è¯•ä½¿ç”¨å¥‡æ ¡éªŒæ„å»º ADU
  - æµ‹è¯•ä½¿ç”¨å¥‡æ ¡éªŒè§£æå’ŒéªŒè¯ ADU
  - æµ‹è¯•å˜ä½“ä¸åŒ¹é…æ—¶çš„è¡Œä¸º
- **æµ‹è¯•ç”¨ä¾‹**:
```csharp
[TestMethod]
public void BuildAdu_OddVariant_CreatesValidFrame()
{
    byte slaveId = 0x01;
    byte[] pdu = { 0x03, 0x00, 0x00, 0x00, 0x0A };
    Span<byte> buffer = stackalloc byte[256];

    int length = ModbusRtuAduBuilder.BuildAdu(buffer, slaveId, pdu, Crc16Variant.Odd);

    Assert.AreEqual(pdu.Length + 3, length);
    Assert.IsTrue(ModbusCrc16.Verify(buffer.Slice(0, length), Crc16Variant.Odd));
}

[TestMethod]
public void ExtractPdu_OddVariant_ExtractsCorrectly()
{
    byte slaveId = 0x01;
    byte[] pdu = { 0x03, 0x00, 0x00, 0x00, 0x0A };
    Span<byte> adu = stackalloc byte[256];
    int aduLength = ModbusRtuAduBuilder.BuildAdu(adu, slaveId, pdu, Crc16Variant.Odd);

    var extractedPdu = ModbusRtuAduParser.ExtractPdu(adu.Slice(0, aduLength), Crc16Variant.Odd);

    Assert.IsTrue(pdu.AsSpan().SequenceEqual(extractedPdu));
}
```

#### æ­¥éª¤ 14: æ›´æ–°ç¤ºä¾‹ä»£ç 
- **æ–‡ä»¶**: `samples/ZHIOT.Modbus.Sample/Program.cs`
- **å˜æ›´å†…å®¹**:
  - åœ¨ `RunModbusRtuSample` æ–¹æ³•ä¸­æ·»åŠ æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨å¥‡æ ¡éªŒ
  - æ·»åŠ æ³¨é‡Šè¯´æ˜ä½•æ—¶éœ€è¦åˆ‡æ¢ CRC å˜ä½“
  - å±•ç¤ºè¿è¡Œæ—¶åˆ‡æ¢ CRC å˜ä½“çš„ç¤ºä¾‹
- **ç¤ºä¾‹ä»£ç **:
```csharp
// ç¤ºä¾‹ 6: CRC-16 å˜ä½“åˆ‡æ¢
Console.WriteLine("6. CRC-16 å˜ä½“åˆ‡æ¢æ¼”ç¤º:");
Console.WriteLine("   å¤§å¤šæ•°è®¾å¤‡ä½¿ç”¨æ ‡å‡†çš„å¶æ ¡éªŒï¼ˆEven, Modbus å®˜æ–¹è§„èŒƒï¼‰");
Console.WriteLine("   ä½†æœ‰äº›è®¾å¤‡ä½¿ç”¨å¥‡æ ¡éªŒï¼ˆOddï¼‰ï¼Œå½“é‡åˆ° CRC é”™è¯¯æ—¶å¯å°è¯•åˆ‡æ¢");
Console.WriteLine();

// é»˜è®¤ä½¿ç”¨å¶æ ¡éªŒï¼ˆModbus æ ‡å‡†ï¼‰
Console.WriteLine("   å½“å‰ä½¿ç”¨: å¶æ ¡éªŒï¼ˆEven - Modbus æ ‡å‡†ï¼‰");
client.Crc16Variant = Crc16Variant.Even;
try
{
    var registers = await client.ReadHoldingRegistersAsync(slaveId, 0, 10);
    Console.WriteLine("   å¶æ ¡éªŒé€šä¿¡æˆåŠŸ!");
}
catch (Exception ex)
{
    Console.WriteLine($"   å¶æ ¡éªŒå¤±è´¥: {ex.Message}");
    Console.WriteLine("   å°è¯•åˆ‡æ¢åˆ°å¥‡æ ¡éªŒ...");
    
    // åˆ‡æ¢åˆ°å¥‡æ ¡éªŒé‡è¯•
    client.Crc16Variant = Crc16Variant.Odd;
    try
    {
        var registers = await client.ReadHoldingRegistersAsync(slaveId, 0, 10);
        Console.WriteLine("   å¥‡æ ¡éªŒé€šä¿¡æˆåŠŸ!");
    }
    catch (Exception ex2)
    {
        Console.WriteLine($"   å¥‡æ ¡éªŒä¹Ÿå¤±è´¥: {ex2.Message}");
    }
}

// æˆ–è€…åœ¨åˆ›å»ºå®¢æˆ·ç«¯æ—¶ç›´æ¥æŒ‡å®š
Console.WriteLine();
Console.WriteLine("   ä¹Ÿå¯ä»¥åœ¨åˆ›å»ºå®¢æˆ·ç«¯æ—¶ç›´æ¥æŒ‡å®š CRC å˜ä½“:");
await using var oddClient = ModbusClientFactory.CreateRtuClient(
    portName: "COM1",
    baudRate: 9600,
    crc16Variant: Crc16Variant.Odd
);
Console.WriteLine("   å·²åˆ›å»ºä½¿ç”¨å¥‡æ ¡éªŒçš„ RTU å®¢æˆ·ç«¯");
```

#### æ­¥éª¤ 15: ç¼–è¯‘å¹¶ä¿®å¤é”™è¯¯
- **æ“ä½œ**: è¿è¡Œ `dotnet build` ç¼–è¯‘æ•´ä¸ªè§£å†³æ–¹æ¡ˆ
- **å¤„ç†**: 
  - æ£€æŸ¥æ˜¯å¦æœ‰ç¼–è¯‘é”™è¯¯
  - ä¿®å¤ç±»å‹ä¸åŒ¹é…ã€å‘½åç©ºé—´ç¼ºå¤±ç­‰é—®é¢˜
  - ç¡®ä¿æ‰€æœ‰æ–°å¢çš„ç±»å‹å’Œæ–¹æ³•éƒ½æ­£ç¡®å¼•ç”¨

#### æ­¥éª¤ 16: è¿è¡Œå•å…ƒæµ‹è¯•
- **æ“ä½œ**: è¿è¡Œ `dotnet test` æ‰§è¡Œæ‰€æœ‰æµ‹è¯•
- **éªŒè¯**:
  - æ‰€æœ‰ç°æœ‰æµ‹è¯•åº”è¯¥ç»§ç»­é€šè¿‡ï¼ˆå‘åå…¼å®¹ï¼‰
  - æ–°å¢çš„ CRC å˜ä½“æµ‹è¯•åº”è¯¥å…¨éƒ¨é€šè¿‡
  - æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡

#### æ­¥éª¤ 17: æ‰‹åŠ¨æµ‹è¯•
- **æ“ä½œ**: è¿è¡Œç¤ºä¾‹ç¨‹åºï¼Œæ‰‹åŠ¨éªŒè¯åŠŸèƒ½
- **æµ‹è¯•åœºæ™¯**:
  - ä½¿ç”¨é»˜è®¤å¶æ ¡éªŒè¿æ¥æ ‡å‡† Modbus RTU è®¾å¤‡
  - æµ‹è¯•è¿è¡Œæ—¶åˆ‡æ¢ CRC å˜ä½“
  - ä½¿ç”¨å¥‡æ ¡éªŒåˆ›å»ºå®¢æˆ·ç«¯
  - éªŒè¯é”™è¯¯åœºæ™¯çš„å¤„ç†

### Testing Strategy

#### å•å…ƒæµ‹è¯•
1. **ModbusCrc16Tests.cs**:
   - æµ‹è¯•å¶æ ¡éªŒè®¡ç®—æ­£ç¡®æ€§ï¼ˆç°æœ‰æµ‹è¯•ï¼‰
   - æµ‹è¯•å¥‡æ ¡éªŒè®¡ç®—æ­£ç¡®æ€§ï¼ˆæ–°å¢ï¼‰
   - æµ‹è¯•ä¸¤ç§å˜ä½“çš„ CRC å€¼å…³ç³»ï¼ˆäº’ä¸ºå–åï¼‰
   - æµ‹è¯• `Verify` æ–¹æ³•å¯¹ä¸¤ç§å˜ä½“çš„æ”¯æŒ
   - æµ‹è¯•å˜ä½“å‚æ•°çš„é»˜è®¤å€¼

2. **ModbusRtuAduBuilderTests.cs**:
   - æµ‹è¯•ä½¿ç”¨å¶æ ¡éªŒæ„å»º ADUï¼ˆç°æœ‰æµ‹è¯•ï¼‰
   - æµ‹è¯•ä½¿ç”¨å¥‡æ ¡éªŒæ„å»º ADUï¼ˆæ–°å¢ï¼‰
   - éªŒè¯æ„å»ºçš„ ADU å¯ä»¥è¢«å¯¹åº”å˜ä½“éªŒè¯é€šè¿‡

3. **ModbusRtuAduParserTests.cs**:
   - æµ‹è¯•ä½¿ç”¨å¶æ ¡éªŒè§£æ ADUï¼ˆç°æœ‰æµ‹è¯•ï¼‰
   - æµ‹è¯•ä½¿ç”¨å¥‡æ ¡éªŒè§£æ ADUï¼ˆæ–°å¢ï¼‰
   - æµ‹è¯•å˜ä½“ä¸åŒ¹é…æ—¶è§£æå¤±è´¥

#### é›†æˆæµ‹è¯•
- åˆ›å»ºæ¨¡æ‹Ÿè®¾å¤‡ï¼Œåˆ†åˆ«ä½¿ç”¨å¥‡å¶æ ¡éªŒ
- æµ‹è¯•å®¢æˆ·ç«¯ä¸ä¸¤ç§è®¾å¤‡çš„é€šä¿¡
- æµ‹è¯•è¿è¡Œæ—¶åˆ‡æ¢å˜ä½“çš„åœºæ™¯

#### æ‰‹åŠ¨æµ‹è¯•
- ä½¿ç”¨ Modbus Slave æ¨¡æ‹Ÿå™¨æµ‹è¯•ï¼ˆå¦‚ Mod_RSsimï¼‰
- æµ‹è¯•çœŸå®çš„ Modbus RTU è®¾å¤‡
- éªŒè¯æ–‡æ¡£å’Œç¤ºä¾‹ä»£ç çš„å‡†ç¡®æ€§

### Implementation Guidelines for Executors

#### Backend Implementation
- **MANDATORY: Compile and Iterate** - å®Œæˆåç«¯ä»£ç ä¿®æ”¹åï¼Œå¿…é¡»ç¼–è¯‘å¹¶è¿­ä»£ä¿®å¤æ‰€æœ‰é”™è¯¯
  - **æ­¥éª¤ 1**: æ¯æ¬¡ä¿®æ”¹æ–‡ä»¶åï¼Œç«‹å³è¿è¡Œç¼–è¯‘éªŒè¯ `dotnet build d:\WorkSpace\OpenSource\ZHIOT.Modbus\ZHIOT.Modbus.sln`
  - **æ­¥éª¤ 2**: ä½¿ç”¨ `get_errors` å·¥å…·æ£€æŸ¥ç¼–è¯‘é”™è¯¯
  - **æ­¥éª¤ 3**: æ ¹æ®é”™è¯¯æ¶ˆæ¯ä¿®å¤é—®é¢˜ï¼ˆç±»å‹ä¸åŒ¹é…ã€å‘½åç©ºé—´ç¼ºå¤±ã€å‚æ•°é”™è¯¯ç­‰ï¼‰
  - **æ­¥éª¤ 4**: é‡å¤æ­¥éª¤ 1-3 ç›´åˆ°ç¼–è¯‘æˆåŠŸæ— é”™è¯¯
  - **æ­¥éª¤ 5**: ç¡®ä¿æ‰€æœ‰è­¦å‘Šéƒ½å·²ä¿®å¤æˆ–æœ‰æ–‡æ¡£è¯´æ˜åŸå› 
  - **DO NOT** åœ¨ç¼–è¯‘æˆåŠŸå‰è®¤ä¸ºå®ç°å®Œæˆ

#### Testing Requirements
- **MANDATORY: Run Tests** - å®ç°å®Œæˆåå¿…é¡»è¿è¡Œæ‰€æœ‰æµ‹è¯•
  - è¿è¡Œå‘½ä»¤: `dotnet test d:\WorkSpace\OpenSource\ZHIOT.Modbus\ZHIOT.Modbus.sln`
  - ç¡®ä¿æ‰€æœ‰ç°æœ‰æµ‹è¯•ç»§ç»­é€šè¿‡ï¼ˆå‘åå…¼å®¹æ€§éªŒè¯ï¼‰
  - ç¡®ä¿æ‰€æœ‰æ–°å¢æµ‹è¯•é€šè¿‡ï¼ˆæ–°åŠŸèƒ½éªŒè¯ï¼‰
  - å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œåˆ†æåŸå› å¹¶ä¿®å¤

## âœ¨ Success Criteria

### åŠŸèƒ½å®Œæ•´æ€§
- âœ… ç”¨æˆ·å¯ä»¥é€šè¿‡ `SerialPortSettings.Crc16Variant` é…ç½® CRC å˜ä½“
- âœ… ç”¨æˆ·å¯ä»¥é€šè¿‡ `IModbusClient.Crc16Variant` å±æ€§è¿è¡Œæ—¶åˆ‡æ¢å˜ä½“
- âœ… é»˜è®¤ä½¿ç”¨å¶æ ¡éªŒï¼ˆModbus æ ‡å‡†ï¼‰ï¼Œä¿æŒå‘åå…¼å®¹
- âœ… å¥‡æ ¡éªŒå’Œå¶æ ¡éªŒéƒ½èƒ½æ­£ç¡®å·¥ä½œ
- âœ… CRC è®¡ç®—å’ŒéªŒè¯é€»è¾‘æ”¯æŒä¸¤ç§å˜ä½“

### è´¨é‡æ ‡å‡†
- âœ… æ‰€æœ‰ç°æœ‰å•å…ƒæµ‹è¯•ç»§ç»­é€šè¿‡
- âœ… æ–°å¢çš„ CRC å˜ä½“æµ‹è¯•å…¨éƒ¨é€šè¿‡
- âœ… ä»£ç ç¼–è¯‘æ— é”™è¯¯æ— è­¦å‘Š
- âœ… API è®¾è®¡ä¸ç°æœ‰é£æ ¼ä¸€è‡´ï¼ˆå‚è€ƒ `ByteOrder`ï¼‰
- âœ… æ€§èƒ½æ— æ˜æ˜¾ä¸‹é™ï¼ˆCRC è®¡ç®—æ˜¯é«˜é¢‘æ“ä½œï¼‰

### æ–‡æ¡£å’Œç¤ºä¾‹
- âœ… æ‰€æœ‰æ–°å¢çš„ç±»ã€æ–¹æ³•ã€å±æ€§éƒ½æœ‰å®Œæ•´çš„ XML æ–‡æ¡£æ³¨é‡Š
- âœ… ç¤ºä¾‹ä»£ç å±•ç¤ºå¦‚ä½•ä½¿ç”¨ CRC å˜ä½“åˆ‡æ¢åŠŸèƒ½
- âœ… æ³¨é‡Šè¯´æ˜ä½•æ—¶éœ€è¦ä½¿ç”¨å¥‡æ ¡éªŒï¼ˆCRC é”™è¯¯æ’æŸ¥åœºæ™¯ï¼‰

### ç”¨æˆ·ä½“éªŒ
- âœ… ä½¿ç”¨ç®€å•ç›´è§‚ï¼Œåªéœ€è®¾ç½®ä¸€ä¸ªæšä¸¾å±æ€§
- âœ… é»˜è®¤è¡Œä¸ºç¬¦åˆæ ‡å‡†ï¼Œä¸éœ€è¦é¢å¤–é…ç½®
- âœ… é”™è¯¯æç¤ºæ¸…æ™°ï¼Œå½“ CRC å¤±è´¥æ—¶æç¤ºç”¨æˆ·å¯ä»¥å°è¯•åˆ‡æ¢å˜ä½“
- âœ… æ”¯æŒè¿è¡Œæ—¶åŠ¨æ€åˆ‡æ¢ï¼Œæ— éœ€é‡æ–°åˆ›å»ºå®¢æˆ·ç«¯
